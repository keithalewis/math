<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Keith A. Lewis" />
  <title>APL</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="math.css" />
  <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      fleqn: true
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">APL</h1>
<p class="author">Keith A. Lewis</p>
</header>
<p>The programming language <em>APL</em> was invented by Ken E. Iverson, a mathematician unsatisfied by the limited expressiveness of FORTRAN when it came to manipulating multidimensional arrays. What follows is a mathematical description of the objects and operations on them he envisioned to scratch that itch. It is simply a matter of giving explicit names to the operations that can be performed on collections of data; what Iverson called “tools of thought.”</p>
<p>There have been many languages inspired by APL and this writeup takes liberties with the classical language. Just as with more modern versions of APL, we index arrays from 0, as in the C language, instead of from 1, like FORTRAN. Our approach is informed by advances in mathematics and best practices for implmementing functional languages on current computer architectures. Don’t be scared off by the Category Theory, we only use a small subset of that to aid organization of the menagerie of APL functions and operators. We take a purely functional view so no side effects are allowed and data cannot be mutated. This can be expensive in terms of computer hardware but using lazy evaluation, lenses, zippers and other implementation techniques is well understood now.</p>
<p>Dijkstra called APT “a mistake carried through to perfection.” I’ve chosen to ignore the first part of Edsger W’s claim.</p>
<h2 id="category-theory">Category Theory</h2>
<p>We put on our Category Theory glasses to clarify the fundamental data structures and transformations between them. The Curry-Howard-Lambek equivalence shows certain classes of proofs and the <span class="math inline">\lambda</span>-calculus, are identical to <em>cartesian closed cateories</em>.</p>
<p>A CCC has a <em>product</em> and <em>exponential</em>. The product behaves like the cartesion product of sets and the exponential represents functions between sets. Every object <span class="math inline">Y</span> defines adjoint functors <span class="math inline">F_Y(X) = X\times Y</span> and <span class="math inline">G_Y(Z) = Z^Y</span> that are related by <span class="math inline">\operatorname{hom}(F_Y(X), Z)\cong \operatorname{hom}(X, G_Y(Z))</span>, which is natural in both <span class="math inline">X</span> and <span class="math inline">Z</span>. We write the explict correspondence as <span class="math inline">(X\times Y)\to Z\leftrightarrow X\to(Y\to Z)</span>. Going from the left to the right form is <em>currying</em>. Going from the right to the left form is <em>uncurrying</em>.</p>
<p>The <em>counit</em> of this adjunction is the <em>evaluation map</em> <span class="math inline">e\colon Z^Y\times Y\to Z</span>.</p>
<p>We can use currying to define composition using arrows. If <span class="math inline">f\colon X\to Y</span> then for any object <span class="math inline">Z</span> define <span class="math inline">f^Z\colon X^Z\to Y^Z</span> to be the curried form of <span class="math inline">(X^Z \times Z)\to Y</span> and <span class="math inline">f_Z\colon Z^Y\to Z^X</span> to be the curried form of <span class="math inline">(Z^Y\times X)\to Z</span>.</p>
<h3 id="set">Set</h3>
<p>We only consider the category <span class="math inline">\mathbf{Set}</span> of sets and functions, which is a CCC, as we will now prove. The function <span class="math inline">f\colon (X\times Y)\to Z</span> corresponds to the function <span class="math inline">g\colon X\to (Y\to Z)</span> via <span class="math inline">f(x,y) = z</span> if and only if <span class="math inline">g(x)y = (g(x))(y) = z</span>. The evaluation function takes a function <span class="math inline">h\colon Y\to Z</span> and a value <span class="math inline">y\in Y</span> to produce <span class="math inline">h(y)\in Z</span>.</p>
<p>If <span class="math inline">f\colon X\to Y</span> then for any set <span class="math inline">Z</span>, <span class="math inline">(f^Z(x))z = f(x(z))</span> where <span class="math inline">x\colon Z\to X</span> and <span class="math inline">(f_Z(y))x = y(f(x))</span> where <span class="math inline">y\colon Y\to Z</span>. We can fly first class and write this as <span class="math inline">f^Zx = fx</span> and <span class="math inline">f_Zy = yf</span> to see that composition on either the left or the right can indeed be expressed as a function.</p>
<p>APL is concerned with products and functions between them (exponentials). Currying lets us reduce functions on a product to functions of one variable. Exponents allows us to express functions between objects as another object. This is the core of any language with first-class functions that can be passed to other functions as data.</p>
<p>A key relationship between products and exponentials is that <span class="math inline">A\times A</span> can be identified with <span class="math inline">A^2</span> where <span class="math inline">2 = \{0,1\}</span>. The pair <span class="math inline">(a_0, a_1)</span> corresponds to the function <span class="math inline">a(0) = a_0</span> and <span class="math inline">a(1) = a_1</span>. For any natural number <span class="math inline">n\in\bm{N}</span>, <span class="math inline">\Pi_n A</span> can be identified with <span class="math inline">A^n</span>, where <span class="math inline">\Pi_n A</span> is the <span class="math inline">n</span>-fold cartesian product of <span class="math inline">A</span>. The correspondence is <span class="math inline">(a_i)\in \Pi_n A</span> corresponds to <span class="math inline">a\in A^n</span> via <span class="math inline">a(i) = a_i</span>, <span class="math inline">i\in n = \{0,\ldots,n-1\}</span>.</p>
<p><strong>Exercise</strong>. <em>Show <span class="math inline">A</span> is in one-to-one correspondence with <span class="math inline">A^1</span></em>.</p>
<p>The elements of <span class="math inline">A^n</span> are called (one dimensional) <em>arrays</em>. They are sometimes called vectors, but that collides with the term for elements of a vector space.</p>
<p>APL is quite handy for dealing with linear algebra. An element of <span class="math inline">A^{n\times n}</span> corresponds to an <span class="math inline">n\times n</span> matrix taking values in <span class="math inline">A</span>. The matrix <span class="math inline">(a_{i,j})</span>, <span class="math inline">a_{i,j}\in A</span>, <span class="math inline">0\le i,j &lt; n</span>, corresponds to the function <span class="math inline">a\colon n\times n\to A</span> via <span class="math inline">a(i,j) = a_{i,j}</span>.</p>
<p>It is even handier when dealing with higher dimensional data. An <span class="math inline">n_0\times\cdots</span> dimensional cube taking values in <span class="math inline">A</span> is just an element of <span class="math inline">A^{n_0\times\cdots}</span>. APL provides primitives for slicing and dicing along any dimensions.</p>
<h3 id="examples">Examples</h3>
<p>APL lets you turn a number into a lot of numbers. The function <span class="math inline">\iota</span> (iota) is used to produce sequences. If <span class="math inline">n\in \bm{N}</span> then <span class="math inline">\iota n = (0, 1, \ldots n-1)</span>. It is a function from <span class="math inline">\bm{N}</span> to <span class="math inline">\bm{N}^* = \cup_{n\ge 0}\bm{N}^n</span>, the set of all finite sequences of natural numbers. In what follows I will usually forget to write <span class="math inline">\iota n</span> and just write <span class="math inline">n</span>.</p>
<p>Using the notation above, the <span class="math inline">n\times n</span> identity matrix can be written as <span class="math inline">\delta^{n\times n}n\times n</span> where <span class="math inline">\delta\colon\bm{N}\times\bm{N}\to\bm{N}</span> is <span class="math inline">\delta(i,j) = 1</span> if <span class="math inline">i = j</span> and <span class="math inline">\delta(i,j) = 0</span> if <span class="math inline">i\not= j</span>. This can be defined for any set <span class="math inline">\delta\colon A^2\to A</span> as long as <span class="math inline">a = b</span> can be interpreted as an element of <span class="math inline">A</span>. For any set <span class="math inline">Z</span>, <span class="math inline">\delta^Z\colon (A\times A)^Z\to A^Z</span>. Taking <span class="math inline">Z = n\times n</span> and <span class="math inline">A = n</span> gives <span class="math inline">\delta^{\n\times n}(n\times n) \in n^{n\times n}</span>. This is an <span class="math inline">n\times n</span> matrix taking values <span class="math inline">\delta(i,j)</span>, aka the identity matrix. APL is parsed right-to-left so we drop the right parentheses to read <span class="math inline">ab</span> as <span class="math inline">a(b)</span>. This is natural in a functional language where statements are chains of function calls.</p>
<p>APL doesn’t pussyfoot around and uses <span class="math inline">\text{$=$}</span> instead of <span class="math inline">\delta</span>.</p>
<p>But wait, that’s not all! This can be written more succinctly as <span class="math inline">\text{$=$}n^2</span>. Recall <span class="math inline">n^2</span> is the same as <span class="math inline">n\times n</span>. If <span class="math inline">f\colon X\to Y</span> we can leave out the <span class="math inline">Z</span> in <span class="math inline">f^Z</span> if the value of <span class="math inline">Z</span> can be deduced from the function arguments. In this case <span class="math inline">\delta^{n^2}\colon (A^2)^{n^2}\to A^{n^2}</span> and we know <span class="math inline">\delta\colon A^2\to A</span> so we must have <span class="math inline">Z = n^2</span>.</p>
<p>We can extend <span class="math inline">\text{$=$}\colon A^k\to A</span> by <span class="math inline">\text{$=$}(a_0,\ldots) = 1</span> if all <span class="math inline">a_j</span> are equal and 0 otherwise. The <span class="math inline">k</span>-dimensional identity matrix is <span class="math inline">\text{$=$}n^k</span>. If we define <span class="math inline">\wedge(A, B) = A\wedge B = A^B</span>, then <span class="math inline">\text{$=$}n\wedge</span> is a function from <span class="math inline">\bm{N}</span> to identity matrices having the dimension of the argument. Further, <span class="math inline">\text{$=$}\wedge</span> allows us to parameterize over <span class="math inline">n</span> too since <span class="math inline">\text{$=$}(\wedge(n,k)) = \text{$=$}(n^k) = \text{$=$}n^k</span>.</p>
<p>Never play code golf with an APLer.</p>
<h2 id="data-and-operators">Data and Operators</h2>
<p>Let <span class="math inline">\bm{R}</span> be the real numbers, or their computer approximation: 64-bit IEEE floating point numbers. Let <span class="math inline">\bm{N}</span> be the natural numbers and <span class="math inline">\bm{Z}</span> be the integers. These are represented by unsigned and signed integers respectively on a computer. They can be categorized by the number of bits used in their computer representation. Mathematically, <span class="math inline">\bm{N}\subseteq\bm{Z}\subseteq\bm{R}</span> but it gets more complicated when considering computer implimentations. APL, like most computer languages, <em>implicitly promotes</em> types to their smallest common type. This leads to problems like the fact that while 32-bit integers can be exactly represented by 64-bit floating point numbers, 64-bit integers cannot. We will ignore these problems and assume all numeric values are real numbers.</p>
<p>The basic data type in APL is a multidimensional array in <span class="math inline">\bm{R}^{\times n*}</span> where <span class="math inline">n^*\in\bm{N}^* = \cup_{n\ge0}\bm{N}</span> is a finite sequence of natural numbers and <span class="math inline">\times</span> is the cartesian product. If <span class="math inline">X</span> is a monoid with binary operator <span class="math inline">\otimes</span> and identity <span class="math inline">1</span> we can extend <span class="math inline">\otimes\colon X^2\to X</span> to <span class="math inline">\otimes\colon X^*\to X</span> by defining <span class="math inline">\otimes(x_0\ldots, x_n) = = x_0\otimes\cdots\otimes x_n</span>.</p>
<h2 id="preliminaries">Preliminaries</h2>
<p>A <em>relation</em> on the sets <span class="math inline">A</span> and <span class="math inline">B</span> is a subset <span class="math inline">R\subseteq A\times B</span>. It is customary to write <span class="math inline">aRb</span> for <span class="math inline">(a,b)\in R</span>. The <em>right coset</em> of <span class="math inline">a\in A</span> under <span class="math inline">R</span> is <span class="math inline">aR = \{b\in B:aRb\}</span> and the <em>left coset</em> of <span class="math inline">b\in B</span> under <span class="math inline">R</span> is <span class="math inline">Rb = \{a\in A:aRb\}</span>. If <span class="math inline">X\subseteq A</span> we define the <em>push forward</em> of <span class="math inline">X</span> under <span class="math inline">R</span> to be <span class="math inline">XR = \cup_{x\in X}xR\subseteq B</span> If <span class="math inline">Y\subseteq B</span> the <em>pull back</em> of <span class="math inline">Y</span> under <span class="math inline">R</span> is <span class="math inline">RY = \cup_{y\in Y}Ry\subseteq A</span>. The <em>domain</em> of a relation <span class="math inline">R\subseteq A\times B</span> is <span class="math inline">\operatorname{dom}R = RB</span> and the <em>range</em>, or <em>codomain</em>, is <span class="math inline">\operatorname{cod}R = AR</span>.</p>
<p>A relation is a <em>function</em> if and only if all right cosets are singletons. In this case we write <span class="math inline">R\colon A\to B</span> and <span class="math inline">R(a) = b</span> for <span class="math inline">aRb</span> where <span class="math inline">b</span> is the unique element of the right coset <span class="math inline">aR</span>. The push forward of <span class="math inline">X\subseteq A</span> is written <span class="math inline">R(X)</span> if <span class="math inline">R</span> is a function.</p>
<p>If all right cosets are singletons or empty we call <span class="math inline">R</span> a <em>partial function</em>. Every partial function can be augmented to a function by adding a special element <span class="math inline">\bot\not\in B</span> to <span class="math inline">B</span> and defining <span class="math inline">\underline{R}\colon A\to B\cup\{\bot\}</span> by <span class="math inline">\underline{R}(a) = R(a)</span> if <span class="math inline">a\in\operatorname{dom}R</span> and <span class="math inline">\underline{R}(a&#39;) = \bot</span> if <span class="math inline">a&#39;\not\in\operatorname{dom}R</span>.</p>
<h2 id="exponential">Exponential</h2>
<p>If <span class="math inline">A</span> and <span class="math inline">B</span> are sets then the <em>exponential</em> is the set of all functions from <span class="math inline">B</span> to <span class="math inline">A</span>, <span class="math inline">A^B = \{f\colon B\to A\}</span>. If <span class="math inline">n\in\mathbf{N}</span> is a natural numbers we identify it with the set <span class="math inline">\{0,\ldots, n - 1\}</span> so <span class="math inline">A^n = \{(a_1,\ldots,a_n)\colon a_i\in A, 1\le i\le n\}</span> represents the functions <span class="math inline">a\colon n\to A</span> where <span class="math inline">a(i) = a_i</span>.</p>
<h2 id="product">Product</h2>
<p>The <em>cartesian product</em> of the sets <span class="math inline">A_0</span> and <span class="math inline">A_1</span> is the set of all pairs of element where the first item belongs to <span class="math inline">A_0</span> and the second item belongs to <span class="math inline">A_1</span>, <span class="math inline">A_0\times A_1 = \{(a_0,a_1):a_0\in A_0 \text{ and } a_1\in A_1\}</span>. It is equipped with two <em>projections</em> <span class="math inline">\pi_0\colon A_0\times A_1\to A_0</span> where <span class="math inline">\pi_0((a_0,a_1)) = a_0</span> and <span class="math inline">\pi_1\colon A_0\times A_0\to A_1</span> where <span class="math inline">\pi_1((a_0,a_1)) = a_1</span>.</p>
<p><strong>Exercise</strong>. <em>Show if <span class="math inline">p_0\colon B\to A_0</span> and <span class="math inline">p_1\colon B\to A_1</span> are functions then there exists a function <span class="math inline">p\colon B\to A_0\times A_1</span> with <span class="math inline">p_0 = \pi_0 p</span> and <span class="math inline">p_1 = \pi_1 p</span></em>.</p>
<p>Any set having this property can be identified with <span class="math inline">A_0\times A_1</span>.</p>
<h2 id="union">Union</h2>
<p>The <em>union</em> of the sets <span class="math inline">A_0</span> and <span class="math inline">A_1</span> is the collection of elements belonging to either <span class="math inline">A_0</span> or <span class="math inline">A_1</span>, <span class="math inline">A_0\cup A_1 = \{a:a\in A_0 \text{ or } a\in A_1\}</span>. The <em>disjoint union</em> is similar to the union but includes information about where elements in the union originated. <span class="math inline">A_0\sqcup A_1 = (\{0\}\times A_0)\cup (\{1\}\times A_1)</span>. It is equipped with two <em>inclusions</em> <span class="math inline">\nu_0\colon A_0\to A_0\sqcup A_1</span> by <span class="math inline">\nu_0(a_0) = (0,a_0)</span> and <span class="math inline">\nu_1\colon A_1\to A_0\sqcup A_1</span> by <span class="math inline">\nu_1(a_1) = (1,a_1)</span>. Note <span class="math inline">A_i</span> is in one-to-one correspondence with <span class="math inline">\{i\}\times A_i</span> via <span class="math inline">a_i \leftrightarrow (i, a_i)</span> for <span class="math inline">a_i\in A_i</span>, <span class="math inline">i = 0,1</span>.</p>
<p><strong>Exercise</strong>. <em>Show if <span class="math inline">n_0\colon A_0\to B</span> and <span class="math inline">n_1\colon A_1\to B</span> are functions then there exists a function <span class="math inline">n\colon A_0\sqcup A_1\to B</span> with <span class="math inline">n_0 = n\nu_0</span> and <span class="math inline">n_1 = n\nu_1</span></em>.</p>
<p>Any set having this property can be identified with <span class="math inline">A_0\sqcup A_1</span>.</p>
<p><strong>Exercise</strong>. <em>Show <span class="math inline">a\in A_0\cap A_1</span> if and only if <span class="math inline">(0,a)</span> and <span class="math inline">(1,a)</span> belong to <span class="math inline">A_0\sqcup A_1</span></em>.</p>
<p>Note <span class="math inline">A_0\sqcup A_1\subseteq 2\times (A_0\cup A_1)</span> where <span class="math inline">2 = \{0,1\}</span> so the disjoint union is a relation with <span class="math inline">\operatorname{cod}A_0\sqcup A_1 = A_0\cup A_1</span>. The left coset of <span class="math inline">a\in A_0\cup A_1</span> is the set <span class="math inline">(A_0\sqcup A_1)a = \{i\in 2:(i,a)\in A_0\sqcup A_1\}</span> so <span class="math inline">a\in A_0\cap A_1</span> if and only if <span class="math inline">(A_0\sqcup A_1)a = 2</span>.</p>
<p>The disjoint union defines a function <span class="math inline">A_0\cup A_1\to\mathcal{P}(2)</span> by <span class="math inline">a\mapsto (A_0\sqcup A_1)a</span>. The intersection is the pull back of <span class="math inline">2 = \{0,1\}\in\mathcal{P}(2)</span>.</p>
<h2 id="pair">Pair</h2>
<p>A <em>pair</em> in <span class="math inline">A_0\times A_1</span> can be identified with an element <span class="math inline">a\in (A_0\sqcup A_1)^2</span>. The pair <span class="math inline">a = (a_0,a_1)</span> corresponds to the function with <span class="math inline">a(0) = (0,a_0)</span> and <span class="math inline">a(1) = (1,a_1)</span>. Note that not every function in <span class="math inline">(A_0\sqcup A_1)^2</span> corresponds to a pair. The function <span class="math inline">a\in(A_0\sqcup A_1)^2</span> comes from a pair if and only if <span class="math inline">a(0)\in \{0\}\times A_0</span> and <span class="math inline">a(1)\in \{1\}\times A_1</span>.</p>
<p>If <span class="math inline">A_0 = A_1 = A</span> then <span class="math inline">A\times A</span> is in one-to-one correspondence with <span class="math inline">A^2</span>. The pair <span class="math inline">(a_0,a_1)</span> corresponds to the function <span class="math inline">a\in A^2</span> defined by <span class="math inline">a(0) = a_0</span> and <span class="math inline">a(1) = a_1</span>.</p>
<p>It is not the case <span class="math inline">A\times A</span> is in one-to-one correspondence with <span class="math inline">(A\sqcup A)^2</span>.</p>
<p><strong>Exercise</strong>. <em>Show <span class="math inline">A\sqcup A = 2\times A</span></em>.</p>
<h2 id="tuple">Tuple</h2>
<p>Products and unions can be defined for any collection of sets <span class="math inline">X_i</span>, <span class="math inline">i\in I</span>. The product <span class="math inline">\Pi X_I = \Pi_{i\in I} X_i</span> has projections <span class="math inline">\pi_i\colon \Pi X_I\to X_i</span> where <span class="math inline">\pi_i(x) = x_i</span>, <span class="math inline">i\in I</span>. The elements of a cartesian product are called <em>tuples</em>.</p>
<p><strong>Exercise</strong>. <em>Show if <span class="math inline">p_i\colon Y\to X_i</span>, <span class="math inline">i\in I</span>, are functions then there exists a function <span class="math inline">p\colon Y\to\Pi X_I</span> with <span class="math inline">p_i = \pi_i p</span></em>.</p>
<p>If <span class="math inline">f_i\colon X_i\to X_i</span>, <span class="math inline">i\in I</span>, then <span class="math inline">\Pi_{i\in I} = \Pi f_I\colon \Pi X_I\to \Pi X_I</span> by <span class="math inline">(x_i)\mapsto (f_i(x_i))</span>, <span class="math inline">i\in I</span>. In terms of projections <span class="math inline">\pi_i\Pi f_I = f_i\pi_i</span>.</p>
<p>More generally, if <span class="math inline">Y_j</span>, <span class="math inline">j\in J</span> is another collection of sets and <span class="math inline">\sigma\colon I\to J</span> then we get a map <span class="math inline">\Pi f_{I,\sigma}\colon \Pi X_I\to \Pi Y_J</span> by <span class="math inline">x\mapsto x\sigma</span> where <span class="math inline">(x_i)\mapsto (y_{\sigma(i})</span>. In terms of projections this is $_j^Y x=</p>
<p>Every function <span class="math inline">\sigma\colon I\to I</span> induces a map <span class="math inline">\Pi X_I\to \Pi X_{\sigma(I)}</span> by <span class="math inline">x\mapsto x\sigma</span> where <span class="math inline">(x_i)\mapsto (x_{\sigma(i)}</span>).</p>
<p><strong>Exercise</strong>. <em>If <span class="math inline">\sigma</span> is bijective then <span class="math inline">\Pi X_I</span> and <span class="math inline">\Pi X_{\sigma(I)}</span> are isomorphic</em>.</p>
<p>In particular <span class="math inline">X_0\times X_1</span> is isomorphic to <span class="math inline">X_1\times X_0</span>. We say cartesian products are commutative up to isomorphism.</p>
<p>We can define projections <span class="math inline">\pi_J\colon \Pi X_I\to \Pi X_J</span> for <span class="math inline">J\subseteq I</span> by <span class="math inline">\pi_J = \Pi_{j\in J}\pi_j</span>.</p>
<p>It is also the case <span class="math inline">X_0\times(X_1\times X_2)</span> and <span class="math inline">(X_0\times X_1)\times X_2</span> are isomorphic to <span class="math inline">X_0\times X_1\times X_2</span>. We say cartesian products are associative up to isomorphism. This can be proved using the properties of projections.</p>
<p>If <span class="math inline">p_i\colon Y\to X_i</span>, <span class="math inline">i = 0,1,2</span>, there exists a map <span class="math inline">q\colon Y\to X_1\times X_2</span> with <span class="math inline">p_i = \pi_i q</span>, <span class="math inline">q = 1,2</span>, hence there also exists a map <span class="math inline">r\colon Y\to X_0\times(X_1\times X_2)</span> with <span class="math inline">pi_0 = \pi_0 r</span> and <span class="math inline">r = \pi_{12) r</span> where <span class="math inline">\pi_{12}</span> is the projection for the se This shows <span class="math inline">X_0\times(X_1\times X_2)</span> is isomorphic to <span class="math inline">X_0\times X_1\times X_2</span>.</p>
<p>We can identify <span class="math inline">\Pi X_I</span> with a subset of <span class="math inline">(\sqcup X_I)^I</span> via <span class="math inline">x\leftrightarrow\underline{x}</span> where <span class="math inline">\underline{x}(i) = (i,\pi_i x)</span>. If <span class="math inline">\sigma\colon I\to I</span> then the composition <span class="math inline">\underline{x}\sigma</span> belongs to <span class="math inline">(\sqcup X_I)^I</span>. Since <span class="math inline">(\underline{x}\sigma)(i) = (\sigma(i),\pi_{\sigma(i)} x)</span> this restricts to a mapping <span class="math inline">\Pi X_I\to \Pi X_{\sigma(I)}</span>.</p>
<p>The disjoint union is <span class="math inline">\sqcup X_I = \cup_{i\in I} \{i\}\times X_i</span> with inclusions <span class="math inline">\nu_i\colon X_i\to\sqcup X_I</span> where <span class="math inline">\nu_i(x_i) = (i, x_i)</span>, <span class="math inline">i\in I</span>.</p>
<p><strong>Exercise</strong>. <em>Show if <span class="math inline">n_i\colon X_i\to Y</span>, <span class="math inline">i\in I</span>, are functions then there exists a function <span class="math inline">n\colon\sqcup X_I\to Y</span> with <span class="math inline">n_i = n\nu_i</span></em>.</p>
<p>Cartesian product is commutative and associative-ish.</p>
<h2 id="curry">Curry</h2>
<p>Exponentials and cartesian products have the property that every function <span class="math inline">f\colon A\times B\to C</span> corresponds to a function <span class="math inline">g\colon A\to C^B</span> via <span class="math inline">f(a,b) = c</span> if and only if <span class="math inline">g(a)(b) = (g(a))(b) = c</span>. This is called <em>currying</em> and the reverse process is <em>uncurrying</em>. Using <span class="math inline">B\to A</span> for <span class="math inline">A^B</span> this becomes <span class="math inline">g\colon A\to (B\to C)</span>.</p>
<p>In general, if <span class="math inline">f\colon\Pi X_I\to Y</span> we can curry on <span class="math inline">J\subseteq I</span> to get <span class="math inline">f_J\colon\Pi X_J\to (\Pi X_{I\setminus J} \to Y)</span>.</p>
<p>We write <span class="math inline">f(a,-)\colon B\to C</span> when currying the second argument and <span class="math inline">f(-,b)\colon A\to C</span> when currying the first argument. Using this notation <span class="math inline">f = f(-,-)</span>.</p>
<h2 id="application">Application</h2>
<p>Given functions <span class="math inline">f_i\colon X_i\to Y_i</span> define <em>componentwise application</em> by <span class="math inline">\Pi f_I\colon \Pi X_I\to \Pi Y_I</span> where <span class="math inline">\pi_i^Y(\Pi f_I(x)) = f_i(\pi_i^X(x))</span> or more simply, <span class="math inline">\pi_i^Y(\Pi f_I) = f_i\pi_i^X</span>.</p>
<p>More generally, if <span class="math inline">\sigma\colon I\to J</span> and <span class="math inline">f_i\colon X_i\to Y_{\sigma(i)}</span> then <span class="math inline">\Pi f_{I,\sigma}\colon X_I\to Y_{\sigma(I)}</span> by <span class="math inline">\pi_{\sigma(i)}^Y(\Pi f_{I,\sigma}) = f_i \pi_i^X</span>.</p>
<p>If we want to be more careful about notation, as Iverson was, we should distinguish between a function <span class="math inline">f\colon A\to B</span> and its <em>push forward</em> <span class="math inline">f^*\colon\mathcal{P}(A)\to\mathcal{P}(B)</span> defined by <span class="math inline">f^*(S) = \{f(s):s\in S\}\subseteq B</span> for <span class="math inline">S\subseteq A</span> where the <em>power set</em> of <span class="math inline">A</span> is the set of all subsets of <span class="math inline">A</span>, <span class="math inline">\mathcal{P}(A) = \{S\subseteq A\}</span>. Similarly, the <em>pull back</em> of <span class="math inline">f</span> is <span class="math inline">f_*\colon\mathcal{P}(B)\to\mathcal{P}(A)</span> defined by <span class="math inline">f_*(T) = \{s\in A:f(s)\in T\}\subseteq A</span> for <span class="math inline">T\subseteq B</span>.</p>
<p>If all <span class="math inline">X_i</span> have the common data type <span class="math inline">X</span> and <span class="math inline">f\colon X\to Y</span> we can apply the single function <span class="math inline">f</span> to all components <span class="math inline">f_\_\colon X_I\to Y_I</span> so <span class="math inline">f_\_(x)(i) = f(x_i)</span>. In APL this is written using diaeresis <span class="math inline">f_\_ = f¨</span>.</p>
<p>The disjoint union <span class="math inline">\sqcup X_I = \sqcup_{i\in I}(\{i\}\times X_i)</span> has inclusions <span class="math inline">\nu_i\colon X_i\to \sqcup X_I</span> where <span class="math inline">\nu_i(x_i) = (i, x_i)</span>.</p>
<p>An element <span class="math inline">x\in\Pi X_I</span> corresponds to a function <span class="math inline">I\to\sqcup X_I</span> where <span class="math inline">x(i) = (i,\pi_i(x))</span>. An element <span class="math inline">x\in\sqcup X_I</span> corresponds to a function <span class="math inline">I\to\sqcup X_I</span> where <span class="math inline">x(i) = (i, x_i)</span>.</p>
<p>Elements of a product are <em>tuples</em>. If all the sets in the product are the same we call the element an <em>array</em>. They are sometimes called vectors, but that collides with the term for elements of a vector space.</p>
<p>If <span class="math inline">J\subseteq I</span> let <span class="math inline">\pi_{J}\colon X_I\to X_J</span> be the <em>projection</em> that selects elements of <span class="math inline">J</span>. If <span class="math inline">I = n</span> we write <span class="math inline">\pi_j</span> instead of <span class="math inline">\pi_{\{j\}}</span> for <span class="math inline">j\in n</span>. A <em>pointed set</em> is a set <span class="math inline">X</span> with a special element <span class="math inline">\star\in X</span>. If the <span class="math inline">X_i</span> are pointed sets we can define the <em>injection</em> <span class="math inline">\nu{J}\colon X_J\to X_I</span> by replacing missing indices with the <span class="math inline">\star</span> for <span class="math inline">X_i</span>, <span class="math inline">i\not\in J</span>. In APL this is written using the <em>backslash</em> operator <span class="math inline">J\setminus = \nu</span>.</p>
<p>A <em>data type</em> is a set <span class="math inline">X</span> together with a collection of operations involving <span class="math inline">X</span>. We assume <span class="math inline">X</span> is finite in what follows since we are concerned with computer implementation. Given data types from some index set <span class="math inline">X_i</span>, <span class="math inline">i\in I</span>, their cartesian product is <span class="math inline">X_I = \Pi_{i\in I}X_i</span>. The projections <span class="math inline">\pi_i\colon X_I\to X_i</span> are defined by <span class="math inline">\pi_i(x) = x_i</span> for <span class="math inline">x\in X_I</span>.</p>
<h2 id="one-dimension">One Dimension</h2>
<h3 id="sequence">Sequence</h3>
<p>The set of all sequences from <span class="math inline">X</span> is <span class="math inline">X^* = \cup_{n\in \mathbf{N}} X^n</span>. Each element has the form <span class="math inline">(x_0,\ldots,x_{n-1})</span> for <span class="math inline">x_i\in X</span> but it does not necessarily mean all elements are stored somewhere. The unary operator <code>?:X^* -&gt; bool</code> tests if a seqence is not empty. The binary operator <code>@</code> returns the first element of the sequence. More generally, <code>@:N x X^* -&gt; X</code> returns the <span class="math inline">n</span>-th element and is called <em>pick</em>. Its default argument is <code>0</code>. Use <code>n @</code> to return the <span class="math inline">n</span>-th element. The operator <code>&lt;</code> removes the first element of the sequence and is called <em>take</em>. Use <code>n &lt;</code> to remove the first <span class="math inline">n</span> elements.</p>
<p>Let <code>s:N -&gt; N</code>, then <code>xs</code> is <code>xs(i) = x(s(i))</code>.</p>
<h3 id="iota">Iota</h3>
<p>We have been using the convention that the natural number <span class="math inline">n</span> represents the set <span class="math inline">\{0,1,\ldots,n-1\}</span>. In APL this is given the name <span class="math inline">\iota n</span>.</p>
<!--
The function _take_ is $\uparrow \mathbf{N}\times X^{\iota n}\to X


# Reduce

If a data type $X$ is an _abelian monoid_ then we can define a measure on the
$\mathcal{P}(X)$ by $\oplus(\{x_j\})
= \oplus_j x_j$ where $\oplus$ is the binary monoid operation
and $\oplus(\emptyset) = 0$ is the identity element of the monoid.
Monoids are pointed sets with their identity being the special element.

Every abelian group is a moniod if we ignore the condition that groups
are required to have inverses. Monoids are only required to have an
associative and commutative binary operation, and an identity element.
Addition and multiplication of numbers are abelian groups.
The set $[-\infty,\infty)$ with binary
operation $x\vee y = \max\{x,y\}$ is an abelian monoid with identity
$-\infty$.  Similarly, $(-\infty,\infty]$ with $x\wedge y = \min\{x,y\}$
and identity $\infty$ is an abelian monoid.

__Exercise__. _Show $\oplus(\{s_j\}) = \oplus_j s_j$ is a well-defined measure on $X$_.

Technically we should write this as $\oplus(\{(j, s_j)\}) = \oplus_j s_j$
to avoid collapsing set elements.

Hint: Since monoid operations are associative and commutative
$\oplus(\{x_1,\ldots,x_n\}) = x_1\oplus\cdots\oplus x_n$ is well-defined.
You need to show $\oplus(U\cup V) = (\oplus(U))\oplus(\oplus(V))$ if
$U\cap V = \emptyset$ for $U,V\subseteq X$.
Start with $\oplus(U\cup \emptyset) = \oplus(U) =
(\oplus(U))\oplus 0 = (\oplus(U))\oplus(\oplus\emptyset)$ and use induction
on the number of elements of $V$.

If $R\in X^n$ then $\oplus R$ is an element of $X$. If $R\in X_I^n$
is a table and $X_i$ is an abelian monoid we can apply its operation at index $i$
to get $\oplus_i R\in X_I^n$ where the rows of $R$ have their $i-th$
component replaced by the constant value $\oplus R_{\{i\}}$.
This is called _reduction_ along column $i$ and in APL it is written using
the _forward slash_ operator $\oplus_i/R$.

## Expand

If an abelian monoid has a total ordering that is discrete with elements
$0 = x_0 < x_1 < \cdots $ define $\iota\colon \mathbf{N}\to $X^\infty$
by $\iota n = (x_0,\ldots,x_n)$.

## Notation

tuple $\Pi_{i\in I} X_i\subseteq (\sqcup_{i\in I} X_i)^I$.

projection $\pi_i\colon\Pi_{i\in I} X_i\to X_i$ where $\pi_i(x) = x_i$.

array $X^I$

## Remarks

A pair $(a,b)$ must satisfy the property $(a,b) = (c,d)$ if and only
if $a = c$ and $b = d$.  Everything in mathematics is a set. What
set is the pair $(a,b)$?  This is a subtle problem with no unique
solution. Kuratowski defined it to be the set $\langle a,b\rangle
= \{\{a\},\{a,b\}\}$.  Clearly if $a = c$ and $b = d$ then $\langle
a,b\rangle$ and $\langle c,d\rangle$ are equal sets. The other direction
is not so trivial. If $a = b$ then $\langle a,b\rangle
=\{\{a\},\{a,a\}\} = \{\{a\},\{a\}\} = \{\{a\}\}$ so $\langle c,d\rangle$
must be a singleton and $\{c\} = \{c,d\}$. This can only
be true if $c = d$, hence $\{a\} = \{c\}$ and $a = c$.

__Exercise__. _Prove the case $a\not= b$_.

Category Theory uses _objects_ and _arrows_ instead of sets.  The
_product_ of sets is defined in terms of objects and arrows.  An object
$C$ with arrows $p\colon C\to A$ and $q\colon C\to B$ is the product of
$A$ and $B$ if and only if for every object $D$ having arrows $r\colon
D\to A$ and $s\colon D\to B$ there exists an arrow $t\colon D\to C$
with $rt = p$ and $st = q$. The product is unique up to isomorphism.

Objects do not have elements in Category Theory, everything must be
defined in terms of objects and arrows. In the category Set we
can define all subsets of the object $S$ as $\hom(S,\{0,1\})$,
the arrows $a\colon S\to\{0,1\}$.
The arrow corresponds to the subset $A = \{s\in S:a(s) = 1\}$.

A _terminal object_ is an object
that always has exactly one arrow from any other object.  In category
Set the terminal objects are singletons and the corresponding arrow can
be thought of as selecting an element from its domain.
If $a\in\hom(S,\{0,1\})$ is terminal then it corresponds to picking
one element from $A$.

The "pairs" of $C$ are terminal objects having domain $C$.
Let $t\colon C\to T$ and $t'\colon C\to T'$ be the unique arrows for $T$ and $T'$.
We also have unique arrows $a\colon A\to T$, $a'\colon A\to T'$
and $b\colon B\to T$, $b'\colon B\to T'$. Since $ap\colon C\to T$
and $a'p\colon C\to T$ we have $ap = a'p$. Likewise $bq = b'q$.


...product as terminal object...
-->
<footer>
Return to <a href="index.html">index</a>.
</footer>
</body>
</html>
