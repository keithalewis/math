<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Keith A. Lewis" />
  <title>APL</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="math.css" />
  <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      fleqn: true
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Literata:wght@300&display=swap" rel="stylesheet"> 
</head>
<body>
<header id="title-block-header">
<h1 class="title">APL</h1>
<p class="author">Keith A. Lewis</p>
</header>
<blockquote>
<p><em>APL is a mistake carried through to perfection</em> — Edsgar W. Dijkstra</p>
</blockquote>
<blockquote>
<p><em>As if that were a bad thing</em> — Me</p>
</blockquote>
<p>A Programming Language <em>APL</em> was invented by Ken E. Iverson, a mathematician unsatisfied by the limited expressiveness of FORTRAN when it came to manipulating multidimensional arrays. What follows is a mathematical description of the objects and operations on them he envisioned to scratch that itch. It is simply a matter of giving explicit names to the operations that can be performed on collections of data; what Iverson called “tools of thought.”</p>
<p>There have been many languages inspired by APL and this writeup takes liberties with the classical language. Our approach is informed by category theory and best practices for implmementing functional languages on current computer architectures. We take a purely functional view so no side effects are allowed and data cannot be mutated. Similar to Everett’s many-world interpretation, this makes it easy to reason about programs mathematically, but can be hard on computers computationally. Using lazy evaluation, <a href="optics.html">optics</a>, and other implementation techniques can help with that.</p>
<p>The two main ideas are composition and (vector space) duality. Let <span class="math inline">Y^X = \{f\colon X\to Y\}</span> be the set of all functions from <span class="math inline">X</span> to <span class="math inline">Y</span>. Given <span class="math inline">f\in Y^X</span> define <span class="math inline">f^Z\colon X^Z\to Y^Z</span> by <span class="math inline">(f^Zx)z = f(xz) = fxz\in Y</span>, <span class="math inline">x\in X^Z</span>, <span class="math inline">z\in Z</span> and <span class="math inline">f_Z\colon Z^Y\to Z^X</span> by <span class="math inline">(f_Zy)x = y(fx) = yfx\in Z</span>, <span class="math inline">y\in Z^Y</span>, <span class="math inline">x\in X</span>. Right to left association is natural in functional languages to chain application. Note <span class="math inline">f^Z\in (Y^Z)^{X^Z}</span> and <span class="math inline">f_Z\in (Z^X)^{Z^Y}</span> are left and right composition by <span class="math inline">f</span> respectively.</p>
<p>Matrix multiplication is just composition of linear transformations. Likewise, inner, outer, and tensor products can be expressed as composition. If <span class="math inline">V</span> is a vector space its <em>dual</em> <span class="math inline">V^*</span> is the set of all linear functions from <span class="math inline">V</span> to its underlying scalar field <span class="math inline">\bm{F}</span>. If <span class="math inline">v\in V</span> and <span class="math inline">v^*\in V^*</span> then the <em>dual pairing</em> <span class="math inline">\langle v, v^*\rangle = v^*v\in\bm{F}</span> acts like an “inner” product and avoids the 2-dimensionally biased distinction between “row” and “column” vectors. Also, <span class="math inline">vv^*\colon V\to V</span> by <span class="math inline">(vv^*)w = v(v^*w) \in V</span>, <span class="math inline">w\in V</span>, is the “tensor” product of <span class="math inline">v</span> and <span class="math inline">v^*</span>. There is no need for any sort of “adjective” product; all of the various products are simply composition of functions.</p>
<p>If <span class="math inline">V = \bm{F}^n</span> then <span class="math inline">V^*\cong\bm{F}^n</span> via the identity function. We write <span class="math inline">v^*\in V^*</span> for the image of <span class="math inline">v\in V</span> and note <span class="math inline">v\cdot w = v^*w</span>.</p>
<p>!!! Move below</p>
<p>If <span class="math inline">V</span> and <span class="math inline">W</span> are vector spaces we let <span class="math inline">W^V</span> be the set of functions from <span class="math inline">V</span> to <span class="math inline">W</span> that preserve the vector space structure. This is commonly called <span class="math inline">\mathcal{L}(V,W)</span> or <span class="math inline">\operatorname{hom}_{\mathbf{Vec}}(V,W)</span>, the space of <em>linear transformations</em> from <span class="math inline">V</span> to <span class="math inline">W</span>. Note <span class="math inline">V^* = FF^V</span>.</p>
<p>To disambiguate linear transformations <span class="math inline">\operatorname{hom}_{\mathbf{Vec}}(V,W)</span> from the set <span class="math inline">\operatorname{hom}_{\mathbf{Set}}(V,W)</span> of all functions from <span class="math inline">V</span> to <span class="math inline">W</span> we can use the <em>forgetful functor</em> <span class="math inline">\mathbf{S}\colon\mathbf{Vec}\to\mathbf{Set}</span> that takes a vector space to the set of elements in the vector space. The functor <span class="math inline">\mathbf{V}\colon\mathbf{Set}\to\mathbf{Vec}</span> with <span class="math inline">\mathbf{V}(S) = \bm{F}^S</span> and <span class="math inline">\mathbf{V}(f)</span> the linear extension from <span class="math inline">f(S)</span> to <span class="math inline">\mathbf{V}(S)</span> is a <em>left adjoint</em> of <span class="math inline">\mathbf{S}</span> since <span class="math inline">\operatorname{hom}_{\mathbf{Vec}}(\mathbf{S}(S), V) \cong \operatorname{hom}_{\mathbf{Set}}(S, \mathbf{V}(V))</span> where <span class="math inline">S\to V</span> in <span class="math inline">\mathbf{Set}</span> corresponds to its unique linear extension <span class="math inline">\bm{F}^S\to V</span> in <span class="math inline">\mathbf{Vec}</span>.</p>
<p>??? is this correct ???</p>
<h2 id="set">Set</h2>
<p>Given a function <span class="math inline">f\colon X\to Y</span> we write <span class="math inline">f(x)</span> as <span class="math inline">fx</span>. If <span class="math inline">g\colon Y\to Z</span> we write the composition <span class="math inline">g(f(x))</span> as <span class="math inline">gfx</span>. If <span class="math inline">h\colon Z\to W</span> then <span class="math inline">h(gf) = (hg)f</span> so writing <span class="math inline">hgf</span> is unambiguous. The identity function of a set <span class="math inline">X</span> is <span class="math inline">1_X\colon X\to X</span> with <span class="math inline">1_X(x) = x</span>, <span class="math inline">x\in X</span> and <span class="math inline">f1_X = f = 1_Yf</span> whenever <span class="math inline">f\colon X\to Y</span>. Sets and functions are the objects and arrows of the category <span class="math inline">\mathbf{Set}</span>.</p>
<p><span class="math inline">\mathbf{Set}</span> is <em>cartesian closed</em> – it has products and exponentials. The product of sets <span class="math inline">X</span> and <span class="math inline">Y</span> is the cartesian product <span class="math inline">X\times Y = \{(x,y):x\in X, y\in Y\}</span> is the set of all pairs from each set and the exponential <span class="math inline">Y^X = \{f\colon X\to Y\}</span> is the set of functions from <span class="math inline">X</span> to <span class="math inline">Y</span>.</p>
<p>The <em>evaluation map</em> <span class="math inline">e\colon Y^X \times X\to Y</span> is defined by <span class="math inline">e(f,x) = f(x)</span>, <span class="math inline">f\in Y^X</span>, <span class="math inline">x\in X</span>. It is just an explicit name for <em>function application</em>.</p>
<p>Products and exponentials are related by <span class="math inline">Z^{X\times Y}</span> is in one-to-one correspondence with <span class="math inline">Z^{Y^X}</span>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Every <span class="math inline">f\in Z^{X\times Y}</span> corresponds to <span class="math inline">g\in Z^{Y^X}</span> via <span class="math inline">f(x,y) = z</span> if and only if <span class="math inline">g(x)(y) = (gx)y = z</span>, <span class="math inline">x\in X</span>, <span class="math inline">y\in Y</span>, <span class="math inline">z\in Z</span>. This correspondence can be written <span class="math display">
    (X\times Y)\to Z \cong X\to(Y\to Z)
</span> Going from left to right is <em>currying</em> and going from right to left is <em>uncurrying</em>. Given <span class="math inline">f\colon X\times Y\to Z</span> we write <span class="math inline">fx\colon Y\to Z</span> for <em>partial application</em> instead of <span class="math inline">g(x)</span>. Given <span class="math inline">g\in Z^(Y^X)</span>, <span class="math inline">f(x,y) = e(g(x),y)</span> and we write ??? <span class="math inline">(x,y)\mapsto (g(x),y)\mapsto g(x)y</span>. Maybe <span class="math inline">eg@0</span>??? <em>Partial map</em>???</p>
<p>We need a language for specifying what dimenstions a function acts on!!!</p>
<h3 id="product">Product</h3>
<p>The cartesian product of a set <span class="math inline">X</span> with itself <span class="math inline">Y</span> times, <span class="math inline">\Pi X_Y = \Pi_{y\in Y} X</span>, can be defined for any set <span class="math inline">Y</span>. It can be identified with <span class="math inline">X^Y</span> and has <em>projections</em> <span class="math inline">\pi_y\colon \Pi X_y\to X</span> defined by <span class="math inline">\pi_y x = x(y)</span>, <span class="math inline">x\in X^Y</span>, $yY. We write <span class="math inline">\pi_y x = x_y</span> and <span class="math inline">x = (x_y)</span> <em>as an array</em> in the product for <span class="math inline">x</span> <em>as a function</em> in the exponential.</p>
<p><strong>Exercise</strong>. <em>If <span class="math inline">u,v\in\Pi X_Y</span> and <span class="math inline">\pi_y u = \pi_y v</span> for all <span class="math inline">y\in Y</span> then <span class="math inline">u = v</span> as functions in <span class="math inline">Y^X</span></em>.</p>
<h3 id="each">Each</h3>
<p>If <span class="math inline">f\colon X\to Y</span> and <span class="math inline">x\colon Z\to X</span> then <span class="math inline">fx\colon Z\to Y</span>. This can be viewed as a function <span class="math inline">f^Z\colon X^Z\to Y^Z</span>. It is common to call this <em>apply</em> or <em>map</em> or <em>fmap</em>, but in APL it is called <em>each</em>. With <span class="math inline">X^Z</span> and <span class="math inline">Y^Z</span> as products, <span class="math inline">x\mapsto fx</span> where <span class="math inline">(fx)_z = f(x_z)</span></p>
<h3 id="index">Index</h3>
<p>If <span class="math inline">y\colon Y\to Z</span> and <span class="math inline">f\colon X\to Y</span> then <span class="math inline">yf\colon X\to Z</span>. This can be viewed as a function <span class="math inline">f_Z\colon Z^Y\to Z^X</span>. It is common to call this <em>projection</em>, but in APL it is called <em>index</em>. With <span class="math inline">Z^Y</span> and <span class="math inline">Z^X</span> as products, <span class="math inline">y\mapsto yf</span> where <span class="math inline">(yf)_x = y_{fx}</span>. If <span class="math inline">X\subseteq Y</span> and <span class="math inline">f\colon X\to Y</span> is the inclusion map then <span class="math inline">Z^Y\to Z^X</span> is the projection <span class="math inline">\Pi Z_Y\to \Pi Z_X</span>. If we write the inclusion map as <span class="math inline">[X]</span> then <span class="math inline">y[X]</span> selects the <span class="math inline">X</span> indices from <span class="math inline">y = y[Y]</span>.</p>
<p>APL is primarily concerned with arrays <span class="math inline">X^{n_0\times\cdots n_{m-1}}</span> and giving names to the functions operating on those. Most often <span class="math inline">X</span> is <span class="math inline">\bm{R}</span>, the set of real numbers, but <span class="math inline">X</span> can also be a set of characters.</p>
<h2 id="example">Example</h2>
<p>APL lets you turn a number into a lot of numbers. The function <span class="math inline">\iota</span> (iota) is used to produce sequences. If <span class="math inline">n\in \bm{N}</span> then <span class="math inline">\iota n = (0, 1, \ldots n-1)</span> where <span class="math inline">\bm{N}</span> is the set of natural numbers. It is related to our convention <span class="math inline">n = \{0,\ldots, n-1\}</span> but <span class="math inline">\iota n</span> is not equal to <span class="math inline">n</span>, it is an element of <span class="math inline">\bm{N}^n</span>. Note <span class="math inline">(\iota n)_i = i</span>, <span class="math inline">i\in n</span> so <span class="math inline">\iota n</span> is the identity function on <span class="math inline">n</span>.</p>
<p>In two dimensions the <span class="math inline">n\times n</span> identity matrix is <span class="math inline">(\delta_{ij})_{i,j\in n}\in \bm{N}^{n\times n}</span>. In APL it is <span class="math inline">\delta</span> applied to each element of <span class="math inline">n\times n</span>. The elements of <span class="math inline">n\times n</span> are <span class="math inline">\{(i,j):i,j\in n\}</span> so <span class="math inline">\delta n\times n = \{\delta(i,j):(i,j)\in n\times n\}</span>.</p>
<p>We can define <span class="math inline">\delta\colon X^n\to X</span> for any <span class="math inline">n</span> by <span class="math inline">\delta(x_0,\ldots,x_n-1) = 1</span> if all <span class="math inline">x_i</span> are equal and <span class="math inline">0</span> otherwise. We should probably use <code>true</code> and <code>false</code> instead of <span class="math inline">1</span> and <span class="math inline">0</span>. If we use <span class="math inline">X</span> as the name of the <em>type conversion</em> function <code>true</code><span class="math inline">\mapsto 1</span> and <code>false</code><span class="math inline">\mapsto 0</span> we would write <span class="math inline">X(\delta)</span>, or <span class="math inline">X\delta</span>, instead of <span class="math inline">\delta</span>.</p>
<p>In APL we use <span class="math inline">\text{$=$}</span> instead of pussyfooting around with <span class="math inline">\delta</span>. This can be written more succinctly as <span class="math inline">\text{$=$}n^2</span> since <span class="math inline">n^2</span> is equivalent to <span class="math inline">n\times n</span>. The <span class="math inline">k</span>-dimensional identity matrix is <span class="math inline">\text{$=$}n^k</span>. If we define <span class="math inline">\widehat{\phantom{x}}(A, B) = A\widehat{\phantom{x}}B = A^B</span>, ⍣ in APL, then <span class="math inline">\text{$=$}\widehat{\phantom{x}}</span> allows us to parameterize over <span class="math inline">n</span> too since <span class="math inline">\text{$=$}\widehat{\phantom{x}}(n,k)</span> is <span class="math inline">\text{$=$}n^k</span>.</p>
<p>Never play code golf with an APLer.</p>
<h3 id="reduce">Reduce</h3>
<p>APL also lets you turn a lot of numbers into one number. For instance, <span class="math inline">+/(a_0,\ldots,a_n) = a_0 + \cdots + a_n</span> where slash (<span class="math inline">/</span>) is called <em>reduce</em>. Other languages call this <em>fold</em>.</p>
<p>Any binary operator <span class="math inline">\bullet\colon X\times X\to X</span> can be extended to <span class="math inline">\bullet/\colon X^n\to X</span> for <span class="math inline">n &gt; 2</span> inductively by <span class="math inline">\bullet/(x_0, x_1, \ldots) = x_0 \bullet (\bullet/(x_1, \dots))</span>. This is called <em>right reduce</em>. If the array is finite then then <em>left reduce</em> is <span class="math inline">/\bullet(x_0,\ldots,x_n) = (/\bullet(x_0,\ldots,x_{n-1}))\bullet x_n</span>. Here we are using <em>infix notation</em> <span class="math inline">\bullet(x,y) = x\bullet y</span>.</p>
<p>If <span class="math inline">\bullet</span> is associative then right and left right reduce are equal. If we define <span class="math inline">\bullet/(x) = x</span> then <span class="math inline">\bullet/(x,y) = (\bullet/x)\bullet(\bullet/y)</span> where <span class="math inline">(x,y)</span> is the concatenation of array <span class="math inline">x</span> with array <span class="math inline">y</span>. Likewise for <span class="math inline">/\bullet</span>. If <span class="math inline">\bullet</span> has an <em>identity element</em> <span class="math inline">e\in X</span> we can define <span class="math inline">\bullet/\emptyset = e = /\bullet\emptyset</span> and this holds when <span class="math inline">x</span> or <span class="math inline">y</span> are empty. These conditions make <span class="math inline">X</span> a <em>monoid</em> under <span class="math inline">\bullet</span>.</p>
<p>If the binary operation is commutative then changing the order of the array elements does not alter the result.</p>
<h3 id="dimension">Dimension</h3>
<p>The main datatype in APL is a <em>multi-dimensional array</em> <span class="math inline">X^{n_0\times\cdots n_{m-1}}</span>. The <em>shape</em> of the array is <span class="math inline">n_0\times\cdots n_{m-1}</span>. It is a function from exponentials to sets defined by <span class="math inline">\rho X^Y = Y</span>. Every <span class="math inline">f\in X^Y</span> is a function <span class="math inline">f\colon X\to Y</span> so <span class="math inline">\rho</span> is a constant function, <span class="math inline">\rho f = Y</span> for all <span class="math inline">f\in X^Y</span>.</p>
<h3 id="lens">Lens</h3>
<p>A <em>lens</em> has a getter and a setter.</p>
<p>set(get(y,x), x) = y, set(get(set(get(y,x)),z) = set(get(y,z),z).</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>In fancy pants category theory language this is expressed as the product functor <span class="math inline">F_Y(X) = X\times Y</span> and the exponential functor <span class="math inline">G_Y(Z) = Z^Y</span> are adjoint: <span class="math inline">\operatorname{hom}(F_Y(X),Z)\cong\operatorname{hom}(X,G_Y(Z))</span>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<footer>
Return to <a href="index.html">index</a>.
</footer>
</body>
</html>
