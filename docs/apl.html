<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Keith A. Lewis" />
  <title>APL</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="math.css" />
  <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      fleqn: true
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Literata:wght@300&display=swap" rel="stylesheet"> 
</head>
<body>
<header id="title-block-header">
<h1 class="title">APL</h1>
<p class="author">Keith A. Lewis</p>
</header>
<blockquote>
<p><em>APL is a mistake carried through to perfection</em> — Edsgar W. Dijkstra</p>
</blockquote>
<blockquote>
<p><em>Besides it is an error to believe that rigour is the enemy of simplicity. On the contrary we find it confirmed by numerous examples that the rigorous method is at the same time the simpler and the more easily comprehended. The very effort for rigor forces us to find out simpler methods of proof</em>. — David Hilbert</p>
</blockquote>
<p>A Programming Language <em>APL</em> was invented by Ken E. Iverson, a mathematician unsatisfied by the limited expressiveness of FORTRAN when it came to manipulating multidimensional arrays. What follows is a mathematical description of the objects and operations on them he envisioned to scratch that itch. It is simply a matter of giving explicit names to the operations that can be performed on collections of data; what Iverson called “tools of thought.”</p>
<p>There have been many languages inspired by APL and this writeup takes liberties with the classical language. Our approach is informed by category theory and best practices for implmementing functional languages on current computer architectures. We take a purely functional view so no side effects are allowed and data cannot be mutated. Similar to Everett’s many-world interpretation, this makes it easy to reason about programs mathematically, but can be computationally hard on computers. Using lazy evaluation, <a href="optics.html">optics</a>, and other implementation techniques can help with that.</p>
<p>The two main ideas are composition and (vector space) duality. Let <span class="math inline">Y^X = \{f\colon X\to Y\}</span> be the set of all functions from <span class="math inline">X</span> to <span class="math inline">Y</span>. Given <span class="math inline">f\in Y^X</span> define <span class="math inline">f^Z\colon X^Z\to Y^Z</span> by <span class="math inline">(f^Zx)z = f(xz) = fxz\in Y</span>, <span class="math inline">x\in X^Z</span>, <span class="math inline">z\in Z</span> and <span class="math inline">f_Z\colon Z^Y\to Z^X</span> by <span class="math inline">(f_Zy)x = y(fx) = yfx\in Z</span>, <span class="math inline">y\in Z^Y</span>, <span class="math inline">x\in X</span>. Right to left association is natural in functional languages to chain application. Note <span class="math inline">f^Z\in (Y^Z)^{X^Z}</span> and <span class="math inline">f_Z\in (Z^X)^{Z^Y}</span> are left and right composition by <span class="math inline">f</span> respectively.</p>
<p>Matrix multiplication is composition of linear transformations. Likewise, inner and outer products can be expressed as composition. If <span class="math inline">V</span> is a vector space its <em>dual</em> <span class="math inline">V^*</span> is the set of all linear functions from <span class="math inline">V</span> to its underlying scalar field <span class="math inline">\bm{F}</span>. If <span class="math inline">v\in V</span> and <span class="math inline">v^*\in V^*</span> then the <em>dual pairing</em> <span class="math inline">\langle v, v^*\rangle = v^*v\in\bm{F}</span> acts like an “inner” product and avoids the 2-dimensionally biased distinction between “row” and “column” vectors. Also, <span class="math inline">vv^*\colon V\to V</span> by <span class="math inline">(vv^*)w = v(v^*w) \in V</span>, <span class="math inline">w\in V</span>, is the “outer”/“tensor” product of <span class="math inline">v</span> and <span class="math inline">v^*</span>. If <span class="math inline">V = \bm{F}^n</span> is the <span class="math inline">n</span>-dimensional vector space on the field <span class="math inline">\bm{F}</span> then <span class="math inline">V^*\cong\bm{F}^n</span> via the identity function. We write <span class="math inline">v^*\in V^*</span> for the image of <span class="math inline">v\in V</span> and note <span class="math inline">v\cdot w = v^*w</span>. There is no need for any sort of “adjective” product – all products are simply composition of functions.</p>
<p><span class="math inline">X^{n0\times n1\times\cdots} \cong X^{n0^{n1^{\cdots}}}</span>.</p>
<p><span class="math inline">{n_0\times n_1\times\cdots}\to X \cong n_0\to n_1\to\cdots\to X</span>.</p>
<p><span class="math inline">n_0\to n_1\to\cdots\to X</span>.</p>
<p><span class="math inline">n_0\to (n_1\times\cdots)\to X</span>.</p>
<!--

!!! Move below

If $V$ and $W$ are vector spaces we let $W^V$ be the set of functions from
$V$ to $W$ that preserve the vector space structure. This is commonly called
$\mathcal{L}(V,W)$ or $\hom_{\cat{Vec}}(V,W)$, the space of _linear transformations_ from $V$ to $W$.
Note $V^* = FF^V$.

To disambiguate linear transformations $\hom_{\cat{Vec}}(V,W)$ from
the set $\hom_{\cat{Set}}(V,W)$ of all functions from $V$ to $W$ we can
use the _forgetful functor_ $\cat{S}\colon\cat{Vec}\to\cat{Set}$ that
takes a vector space to the set of elements in the vector space. The
functor $\cat{V}\colon\cat{Set}\to\cat{Vec}$ with $\cat{V}(S) = \FF^S$
and $\cat{V}(f)$ the linear extension from $f(S)$ to $\cat{V}(S)$ is
a _left adjoint_ of $\cat{S}$
since $\hom_{\cat{Vec}}(\cat{S}(S), V)
\cong \hom_{\cat{Set}}(S, \cat{V}(V))$ where $S\to V$ in $\cat{Set}$
corresponds to its unique linear extension $\FF^S\to V$ in $\cat{Vec}$.

??? is this correct ???

-->
<h2 id="set">Set</h2>
<p>Given a function <span class="math inline">f\colon X\to Y</span> we write <span class="math inline">f(x)</span> as <span class="math inline">fx</span>. If <span class="math inline">g\colon Y\to Z</span> we write the composition <span class="math inline">g(f(x))</span> as <span class="math inline">gfx</span>. If <span class="math inline">h\colon Z\to W</span> then <span class="math inline">h(gf) = (hg)f</span> so writing <span class="math inline">hgf</span> is unambiguous. The identity function of a set <span class="math inline">X</span> is <span class="math inline">1_X\colon X\to X</span> with <span class="math inline">1_X(x) = x</span>, <span class="math inline">x\in X</span> and <span class="math inline">f1_X = f = 1_Yf</span> whenever <span class="math inline">f\colon X\to Y</span>. Sets and functions are the objects and arrows of the category <span class="math inline">\mathbf{Set}</span>.</p>
<p><span class="math inline">\mathbf{Set}</span> is <em>cartesian closed</em> – it has products and exponentials. The product of sets <span class="math inline">X</span> and <span class="math inline">Y</span> is the cartesian product <span class="math inline">X\times Y = \{(x,y):x\in X, y\in Y\}</span> is the set of all pairs from each set and the exponential <span class="math inline">Y^X = \{f\colon X\to Y\}</span> is the set of functions from <span class="math inline">X</span> to <span class="math inline">Y</span>.</p>
<p>The <em>evaluation map</em> <span class="math inline">e_{X,Y} = e\colon Y^X \times X\to Y</span> is defined by <span class="math inline">e(f,x) = f(x)</span>, <span class="math inline">f\in Y^X</span>, <span class="math inline">x\in X</span>. It is just an explicit name for <em>function application</em>.</p>
<p>Products and exponentials are related by <span class="math inline">Z^{X\times Y}</span> is in one-to-one correspondence with <span class="math inline">Z^{Y^X}</span>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Every <span class="math inline">f\in Z^{X\times Y}</span> corresponds to <span class="math inline">g\in Z^{Y^X}</span> via <span class="math inline">f(x,y) = z</span> if and only if <span class="math inline">g(x)(y) = (gx)y = z</span>, <span class="math inline">x\in X</span>, <span class="math inline">y\in Y</span>, <span class="math inline">z\in Z</span>. This correspondence can be written <span class="math display">
    (X\times Y)\to Z \cong X\to(Y\to Z)
</span> Going from left to right is <em>currying</em> and going from right to left is <em>uncurrying</em>.</p>
<p>Product and disjoint union are related by <span class="math inline">\Pi_{j\in J} X^{I_j}\cong X^{\sqcup_{j\in J} I_j}</span> where <span class="math inline">X</span> is any set and <span class="math inline">(I_j)_{j\in J}</span> is any indexed collection of sets &amp;endash; the product of exponentials is the exponential of the sum. The element <span class="math inline">x\in\Pi_{j\in J} X^{I_j}</span> corresponds to <span class="math inline">\hat{x}\in X^{\sqcup_{j\in J} I_j}</span> via <span class="math inline">\pi_j x = \hat{x}\nu_j</span> where <span class="math inline">\pi_j\colon\Pi_{j\in J}\to X_j</span> are the projection defining the product and <span class="math inline">\nu_j\colon X_j\to\sqcup_{j\in J}</span> are the injections defining the disjoint sum. If <span class="math inline">I_j = \{j\}</span>, <span class="math inline">j\in J</span>, this becomes <span class="math inline">\Pi_{j\in J} X = X_J\cong X^J</span>. The element <span class="math inline">x = (x_j)\in X_J</span> corresponds to <span class="math inline">\hat{x}\in X^J</span> via <span class="math inline">x_j = \hat{x}(j)</span>, <span class="math inline">j\in J</span>.</p>
<h3 id="each">Each</h3>
<p>If <span class="math inline">f\colon X\to Y</span> and <span class="math inline">x\colon Z\to X</span> then <span class="math inline">fx\colon Z\to Y</span>. This can be viewed as a function <span class="math inline">f^Z\colon X^Z\to Y^Z</span>. It is common to call this <em>apply</em> or <em>map</em> or <em>fmap</em>, but in APL it is called <em>each</em>. With <span class="math inline">X^Z</span> and <span class="math inline">Y^Z</span> as products, <span class="math inline">x\mapsto fx</span> where <span class="math inline">(fx)_z = f(x_z)</span></p>
<h3 id="index">Index</h3>
<p>If <span class="math inline">y\colon Y\to Z</span> and <span class="math inline">f\colon X\to Y</span> then <span class="math inline">yf\colon X\to Z</span>. This can be viewed as a function <span class="math inline">f_Z\colon Z^Y\to Z^X</span>. It is common to call this <em>projection</em>, but in APL it is called <em>index</em>. With <span class="math inline">Z^Y</span> and <span class="math inline">Z^X</span> as products, <span class="math inline">y\mapsto yf</span> where <span class="math inline">(yf)_x = y_{fx}</span>. If <span class="math inline">X\subseteq Y</span> and <span class="math inline">f\colon X\to Y</span> is the inclusion map then <span class="math inline">Z^Y\to Z^X</span> is the projection <span class="math inline">\Pi Z_Y\to \Pi Z_X</span>. If we write the inclusion map as <span class="math inline">[X]</span> then <span class="math inline">y[X]</span> selects the <span class="math inline">X</span> indices from <span class="math inline">y = y[Y]</span>.</p>
<p>APL is primarily concerned with arrays <span class="math inline">X^{n_0\times\cdots n_{m-1}}</span> and giving names to the functions operating on those. Most often <span class="math inline">X</span> is <span class="math inline">\bm{R}</span>, the set of real numbers, but <span class="math inline">X</span> can also be a set of characters.</p>
<h2 id="example">Example</h2>
<p>APL lets you turn a number into a lot of numbers. The function <span class="math inline">\iota</span> (iota) is used to produce sequences. If <span class="math inline">n\in \bm{N}</span> then <span class="math inline">\iota n = (0, 1, \ldots n-1)</span> where <span class="math inline">\bm{N}</span> is the set of natural numbers. It is related to our convention <span class="math inline">n = \{0,\ldots, n-1\}</span> but <span class="math inline">\iota n</span> is not equal to <span class="math inline">n</span>, it is an element of <span class="math inline">\bm{N}^n</span>. Note <span class="math inline">(\iota n)_i = i</span>, <span class="math inline">i\in n</span> so <span class="math inline">\iota n</span> is the identity function on <span class="math inline">n</span>.</p>
<p>In two dimensions the <span class="math inline">n\times n</span> identity matrix is <span class="math inline">(\delta_{ij})_{i,j\in n}\in \bm{N}^{n\times n}</span>. In APL it is <span class="math inline">\delta</span> applied to each element of <span class="math inline">n\times n</span>. The elements of <span class="math inline">n\times n</span> are <span class="math inline">\{(i,j):i,j\in n\}</span> so <span class="math inline">\delta n\times n = \{\delta(i,j):(i,j)\in n\times n\}</span>.</p>
<p>We can define <span class="math inline">\delta\colon X^n\to X</span> for any <span class="math inline">n</span> by <span class="math inline">\delta(x_0,\ldots,x_n-1) = 1</span> if all <span class="math inline">x_i</span> are equal and <span class="math inline">0</span> otherwise. We should probably use <code>true</code> and <code>false</code> instead of <span class="math inline">1</span> and <span class="math inline">0</span>. If we use <span class="math inline">X</span> as the name of the <em>type conversion</em> function <code>true</code><span class="math inline">\mapsto 1</span> and <code>false</code><span class="math inline">\mapsto 0</span> we would write <span class="math inline">X(\delta)</span>, or <span class="math inline">X\delta</span>, instead of <span class="math inline">\delta</span>.</p>
<p>In APL we use <span class="math inline">\text{$=$}</span> instead of pussyfooting around with <span class="math inline">\delta</span>. This can be written more succinctly as <span class="math inline">\text{$=$}n^2</span> since <span class="math inline">n^2</span> is equivalent to <span class="math inline">n\times n</span>. The <span class="math inline">k</span>-dimensional identity matrix is <span class="math inline">\text{$=$}n^k</span>. If we define <span class="math inline">\widehat{\phantom{x}}(A, B) = A\widehat{\phantom{x}}B = A^B</span>, ⍣ in APL, then <span class="math inline">\text{$=$}\widehat{\phantom{x}}</span> allows us to parameterize over <span class="math inline">n</span> too since <span class="math inline">\text{$=$}\widehat{\phantom{x}}(n,k)</span> is <span class="math inline">\text{$=$}n^k</span>.</p>
<p>Never play code golf with an APLer.</p>
<h3 id="reduce">Reduce</h3>
<p>APL also lets you turn a lot of numbers into one number. For instance, <span class="math inline">+/(a_0,\ldots,a_n) = a_0 + \cdots + a_n</span> where slash (<span class="math inline">/</span>) is called <em>reduce</em>. Other languages call this <em>fold</em>.</p>
<p>Any binary operator <span class="math inline">\bullet\colon X\times X\to X</span> can be extended to <span class="math inline">\bullet/\colon X^n\to X</span> for <span class="math inline">n &gt; 2</span> inductively by <span class="math inline">\bullet/(x_0, x_1, \ldots) = x_0 \bullet (\bullet/(x_1, \dots))</span>. This is called <em>right reduce</em>. If the array is finite then then <em>left reduce</em> is <span class="math inline">/\bullet(x_0,\ldots,x_n) = (/\bullet(x_0,\ldots,x_{n-1}))\bullet x_n</span>. Here we are using <em>infix notation</em> <span class="math inline">\bullet(x,y) = x\bullet y</span>.</p>
<p>If <span class="math inline">\bullet</span> is associative then right and left right reduce are equal. If we define <span class="math inline">\bullet/(x) = x</span> then <span class="math inline">\bullet/(x,y) = (\bullet/x)\bullet(\bullet/y)</span> where <span class="math inline">(x,y)</span> is the concatenation of array <span class="math inline">x</span> with array <span class="math inline">y</span>. Likewise for <span class="math inline">/\bullet</span>. If <span class="math inline">\bullet</span> has an <em>identity element</em> <span class="math inline">e\in X</span> we can define <span class="math inline">\bullet/\emptyset = e = /\bullet\emptyset</span> and this holds when <span class="math inline">x</span> or <span class="math inline">y</span> are empty. These conditions make <span class="math inline">X</span> a <em>monoid</em> under <span class="math inline">\bullet</span>.</p>
<p>If the binary operation is commutative then changing the order of the array elements does not alter the result.</p>
<h3 id="dimension">Dimension</h3>
<p>The main datatype in APL is a <em>multi-dimensional array</em> <span class="math inline">X^{n_0\times\cdots n_{m-1}}</span>. The <em>shape</em> of the array is <span class="math inline">n_0\times\cdots n_{m-1}</span>. It is a function from exponentials to sets defined by <span class="math inline">\rho X^Y = Y</span>. Every <span class="math inline">f\in X^Y</span> is a function <span class="math inline">f\colon X\to Y</span> so <span class="math inline">\rho</span> is a constant function, <span class="math inline">\rho f = Y</span> for all <span class="math inline">f\in X^Y</span>.</p>
<h2 id="remarks">Remarks</h2>
<p><span class="math inline">\Pi X_I = \Pi_{i\in I} X_i</span>, <span class="math inline">\pi_i\colon\Pi X_I\to X_i</span>, <span class="math inline">\pi_i(x) = x_i</span> projections.</p>
<p>If <span class="math inline">X = X_i</span>, <span class="math inline">i\in I</span> then <span class="math inline">X_I = \Pi X_I = \Pi_{i\in I} X\cong X^I</span> via <span class="math inline">x = (x_i)\in \Pi X_I</span> correspoinds to <span class="math inline">\hat{x}\in X^I</span> via <span class="math inline">x_i = \hat{x}(i)</span>. More generally, <span class="math inline">\Pi_{i\in I} X_{I_i}\cong X^{\sqcup_{i\in I} I_i}</span> via <span class="math inline">x = (x_i)\in \Pi_I X_{I_i}</span> correspoinds to <span class="math inline">\hat{x}\in X^I</span> via <span class="math inline">x_i = \hat{x}(i)</span>. via <span class="math inline">x_{i_j}} = x(i_j)</span>, <span class="math inline">i_j\in I_j</span> shows the fundamental relationship between product and disjoint sum.</p>
<p>If <span class="math inline">f\colon X\to Y</span> then <span class="math inline">f^Z\colon X^Z\to Y^Z</span> via <span class="math inline">f^Zx = fx</span> and <span class="math inline">f_Z\colon Z^Y\to Z^X</span> via <span class="math inline">f_Zy = yf</span>.</p>
<p>via <span class="math inline">(x_j)\leftrightarrow x</span> for <span class="math inline">x_j\in X^{I_j}</span> where <span class="math inline">x(i_j) = x_j(i)</span>, for <span class="math inline">i_j = (j,i)\in \sqcup_j I_j</span>.</p>
<p>Indices: If <span class="math inline">\sigma\colon m\to n</span> then <span class="math inline">\sigma_X\colon X^n\to X^m</span> via <span class="math inline">x\in X^n\mapsto x\sigma\in X^m</span>. We write <span class="math inline">\sigma = (\sigma_i)</span> where <span class="math inline">\sigma(i) = \sigma_i\in n</span> for <span class="math inline">i\in m</span>.</p>
<p>For example, if <span class="math inline">f\colon X^2\to Y</span> then <span class="math inline">f(1,0)\colon X^2\to Y</span> via <span class="math inline">f(0,1)(x_0,x_1) = f(x_1,x_0)</span>. If <span class="math inline">f\colon X^2\to Y</span> then <span class="math inline">f(0,0)\colon X\to Y</span> via <span class="math inline">f(0,0)(x) = f(x, x)</span>.</p>
<p>Currying: If <span class="math inline">f\colon X^I\to Y</span> and <span class="math inline">J\subseteq I</span> define <span class="math inline">?\colon I\to I</span> by <span class="math inline">X^{I\setminus J}\times X^J\to X^I</span></p>
<p><span class="math inline">f\colon\Pi X_n\to Y</span></p>
<p>If <span class="math inline">J\subseteq I</span> and <span class="math inline">[J]\colon J\to I</span> is inclusion then <span class="math inline">y[J]\in X_J</span> projects <span class="math inline">y\in X_I</span> to <span class="math inline">X_J</span>.</p>
<p>Currying: <span class="math inline">X\times Y\to Z\cong (Z^Y)^X</span> via <span class="math inline">f(x,y) = z</span> iff <span class="math inline">(fx)y = z</span>.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>In fancy pants category theory language this is expressed as the product functor <span class="math inline">F_Y(X) = X\times Y</span> and the exponential functor <span class="math inline">G_Y(Z) = Z^Y</span> are adjoint: <span class="math inline">\operatorname{hom}(F_Y(X),Z)\cong\operatorname{hom}(X,G_Y(Z))</span>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<footer>
Return to <a href="index.html">index</a>.
</footer>
</body>
</html>
