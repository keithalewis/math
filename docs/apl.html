<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Keith A. Lewis" />
  <title>APL</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="math.css" />
  <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      fleqn: true
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>

<header id="title-block-header">
<h1 class="title">APL</h1>
<p class="author">Keith A. Lewis</p>
</header>
<p>The programming language <em>APL</em> was invented by Ken E. Iverson, a mathematician unsatisfied by the limited expressiveness of FORTRAN when it came to manipulating multidimensional arrays. What follows is a mathematical description of the objects and operations on them he invented to scratch that itch. It is simply a matter of giving explicit names to the operations that can be performed on collections of data; what Iverson called “tools of thought.”</p>
<h2 id="preliminaries">Preliminaries</h2>
<p>A <em>relation</em> on the sets <span class="math inline">A</span> and <span class="math inline">B</span> is a subset <span class="math inline">R\subseteq A\times B</span>. It is customary to write <span class="math inline">aRb</span> for <span class="math inline">(a,b)\in R</span>. The <em>right coset</em> of <span class="math inline">a\in A</span> under <span class="math inline">R</span> is <span class="math inline">aR = \{b\in B:aRb\}</span> and the <em>left coset</em> of <span class="math inline">b\in B</span> under <span class="math inline">R</span> is <span class="math inline">Rb = \{a\in A:aRb\}</span>. If <span class="math inline">X\subseteq A</span> we define the <em>push forward</em> of <span class="math inline">X</span> under <span class="math inline">R</span> to be <span class="math inline">XR = \cup_{x\in X}xR\subseteq B</span> If <span class="math inline">Y\subseteq B</span> the <em>pull back</em> of <span class="math inline">Y</span> under <span class="math inline">R</span> is <span class="math inline">RY = \cup_{y\in Y}Ry\subseteq A</span>. The <em>domain</em> of a relation <span class="math inline">R\subseteq A\times B</span> is <span class="math inline">\dom R = RB</span> and the <em>range</em>, or <em>codomain</em>, is <span class="math inline">\cod R = AR</span>.</p>
<p>A relation is a <em>function</em> if and only if all right cosets are singletons. In this case we write <span class="math inline">R\colon A\to B</span> and <span class="math inline">R(a) = b</span> for <span class="math inline">aRb</span> where <span class="math inline">b</span> is the unique element of the right coset <span class="math inline">aR</span>. The push forward of <span class="math inline">X\subseteq A</span> is written <span class="math inline">R(X)</span> if <span class="math inline">R</span> is a function.</p>
<p>If all right cosets are singletons or empty we call <span class="math inline">R</span> a <em>partial function</em>. Every partial function can be augmented to a function by adding a special element <span class="math inline">\bot\not\in B</span> to <span class="math inline">B</span> and defining <span class="math inline">\hat{R}\colon A\to B\cup\{\bot\}</span> by <span class="math inline">\hat{R}(a) = R(a)</span> if <span class="math inline">a\in\dom R</span> and <span class="math inline">\hat{R}(a&#39;) = \bot</span> if <span class="math inline">a&#39;\not\in\dom R</span>.</p>
<h2 id="exponential">Exponential</h2>
<p>If <span class="math inline">A</span> and <span class="math inline">B</span> are sets then the <em>exponential</em> is the set of all functions from <span class="math inline">B</span> to <span class="math inline">A</span>, <span class="math inline">A^B = \{f\colon B\to A\}</span>. If <span class="math inline">n\in\bm{N}</span> is a natural numbers we identify it with the set <span class="math inline">\{0,\ldots, n - 1\}</span> so <span class="math inline">A^n = \{(a_1,\ldots,a_n)\colon a_i\in A, 1\le i\le n\}</span> represents the functions <span class="math inline">a\colon n\to A</span> where <span class="math inline">a(i) = a_i</span>.</p>
<h2 id="product">Product</h2>
<p>The <em>cartesian product</em> of the sets <span class="math inline">A_0</span> and <span class="math inline">A_1</span> is the set of all pairs of element where the first item belongs to <span class="math inline">A_0</span> and the second item belongs to <span class="math inline">A_1</span>, <span class="math inline">A_0\times A_1 = \{(a_0,a_1):a_0\in A_0 \text{ and } a_1\in A_1\}</span>. It is equipped with two <em>projections</em> <span class="math inline">\pi_0\colon A_0\times A_1\to A_0</span> where <span class="math inline">\pi_0((a_0,a_1)) = a_0</span> and <span class="math inline">\pi_1\colon A_0\times A_0\to A_1</span> where <span class="math inline">\pi_1((a_0,a_1)) = a_1</span>.</p>
<p><strong>Exercise</strong>. <em>Show if <span class="math inline">p_0\colon B\to A_0</span> and <span class="math inline">p_1\colon B\to A_1</span> are functions then there exists a function <span class="math inline">t\colon B\to A_0\times A_1</span> with <span class="math inline">p_0 = \pi_0 t</span> and <span class="math inline">p_1 = \pi_1 t</span></em>.</p>
<p>Any set having this property can be identified with <span class="math inline">A_0\times A_1</span>.</p>
<p>Products and unions can be defined for any collection of sets <span class="math inline">X_i</span>, <span class="math inline">i\in I</span>. The product <span class="math inline">\Pi X_I = \Pi_{i\in I} X_i</span> has projections <span class="math inline">\pi_i\colon \Pi X_I\to X_i</span> where <span class="math inline">\pi_i(x) = x_i</span>.</p>
<p>Given <span class="math inline">\sigma\colon I\to I</span> define <span class="math inline">x\sigma\in\Pi X_{\sigma(I)}</span> by <span class="math inline">(x\sigma)_i = x_{\sigma(i)}</span>.</p>
<p><strong>Exercise</strong>. _Show if <span class="math inline">\sigma</span> is bijective then so is <span class="math inline">\Sigma</span>.</p>
<p>The function <span class="math inline">\sigma\colon\{0,1}\}\to \{0,1\}</span> were <span class="math inline">\sigma(0) = 1</span> and <span class="math inline">\sigma(1) = 0</span> shows <span class="math inline">A_0\times A_1</span> is isomorphic to <span class="math inline">A_1\times A_0</span>.</p>
<p>Show <span class="math inline">A_0\times(A_1\times A_2)</span> is isomorphic to <span class="math inline">(A_0\times A_1)\times A_2</span>.</p>
<p>Cartesian product is commutative and associative-ish.</p>
<p>Given collections <span class="math inline">X_i</span>, <span class="math inline">i\in I</span> and <span class="math inline">Y_j</span>, <span class="math inline">j\in J</span></p>
<h2 id="curry">Curry</h2>
<p>Exponentials and cartesian products have the property that every function <span class="math inline">f\colon A\times B\to C</span> corresponds to a function <span class="math inline">g\colon A\to C^B</span> via <span class="math inline">f(a,b) = c</span> if and only if <span class="math inline">g(a)(b) = (g(a))(b) = c</span>. This is called <em>currying</em> and the reverse process is <em>uncurrying</em>. Using <span class="math inline">B\to A</span> for <span class="math inline">A^B</span> this becomes <span class="math inline">g\colon A\to (B\to C)</span>.</p>
<p>In general, if <span class="math inline">f\colon\Pi X_I\to Y</span> we can curry on <span class="math inline">J\subseteq I</span> to get <span class="math inline">f_J\colon\Pi X_J\to (\Pi X_{I\setminus J} \to Y)</span>.</p>
<p>We write <span class="math inline">f(a,-)\colon B\to C</span> when currying the second argument and <span class="math inline">f(-,b)\colon A\to C</span> when currying the first argument. Using this notation <span class="math inline">f = f(-,-)</span>.</p>
<h2 id="application">Application</h2>
<p>Given functions <span class="math inline">f_i\colon X_i\to Y_i</span> define <em>componentwise application</em> by <span class="math inline">\Pi f_I\colon \Pi X_I\to \Pi Y_I</span> where <span class="math inline">\pi_i^Y(\Pi f_I(x)) = f_i(\pi_i^X(x))</span> or more simply, <span class="math inline">\pi_i^Y(\Pi f_I) = f_i\pi_i^X</span>.</p>
<p>More generally, if <span class="math inline">\sigma\colon I\to J</span> and <span class="math inline">f_i\colon X_i\to Y_{\sigma(i)}</span> then <span class="math inline">\Pi f_{I,\sigma}\colon X_I\to Y_{\sigma(I)}</span> by <span class="math inline">\pi_{\sigma(i)}^Y(\Pi f_{I,\sigma}) = f_i \pi_i^X</span>.</p>
<p>If we want to be more careful about notation, as Iverson was, we should distinguish between a function <span class="math inline">f\colon A\to B</span> and its <em>push forward</em> <span class="math inline">f^*\colon\mathcal{P}(A)\to\mathcal{P}(B)</span> defined by <span class="math inline">f^*(S) = \{f(s):s\in S\}\subseteq B</span> for <span class="math inline">S\subseteq A</span> where the <em>power set</em> of <span class="math inline">A</span> is the set of all subsets of <span class="math inline">A</span>, <span class="math inline">\mathcal{P}(A) = \{S\subseteq A\}</span>. Similarly, the <em>pull back</em> of <span class="math inline">f</span> is <span class="math inline">f_*\colon\mathcal{P}(B)\to\mathcal{P}(A)</span> defined by <span class="math inline">f_*(T) = \{s\in A:f(s)\in T\}\subseteq A</span> for <span class="math inline">T\subseteq B</span>.</p>
<p>If all <span class="math inline">X_i</span> have the common data type <span class="math inline">X</span> and <span class="math inline">f\colon X\to Y</span> we can apply the single function <span class="math inline">f</span> to all components <span class="math inline">f_\_\colon X_I\to Y_I</span> so <span class="math inline">f_\_(x)(i) = f(x_i)</span>. In APL this is written using diaeresis <span class="math inline">f_\_ = f¨</span>.</p>
<h2 id="union">Union</h2>
<p>The <em>union</em> of the sets <span class="math inline">A_0</span> and <span class="math inline">A_1</span> is the collection of elements belonging to either <span class="math inline">A_0</span> or <span class="math inline">A_1</span>, <span class="math inline">A_0\cup A_1 = \{b:b\in A_0 \text{ or } b\in A_1\}</span>. The <em>disjoint union</em> is similar to the union but includes information about where elements in the union originated. <span class="math inline">A_0\sqcup A_1 = (\{0\}\times A_0)\cup (\{1\}\times A_1)</span>. It is equipped with two <em>inclusions</em> <span class="math inline">\nu_0\colon A_0\to A_0\sqcup A_1</span> by <span class="math inline">\nu_0(a_0) = (0,a_0)</span> and <span class="math inline">\nu_1\colon A_1\to A_0\sqcup A_1</span> by <span class="math inline">\nu_1(a_1) = (1,a_1)</span>. Note <span class="math inline">A_i</span> is in one-to-one correspondence with <span class="math inline">\{i\}\times A_i</span> via <span class="math inline">a_i \leftrightarrow (i, a_i)</span> for <span class="math inline">a_i\in A_i</span> for <span class="math inline">i = 0,1</span>.</p>
<p><strong>Exercise</strong>. <em>Show if <span class="math inline">n_0\colon A_0\to B</span> and <span class="math inline">n_1\colon A_1\to B</span> are functions then there exists a function <span class="math inline">i\colon A_0\sqcup A_1\to B</span> with <span class="math inline">n_0 = i\nu_0</span> and <span class="math inline">n_1 = i\nu_1</span></em>.</p>
<p>Any set having this property can be identified with <span class="math inline">A_0\sqcup A_1</span>.</p>
<p>A <em>pair</em> can be identified with an element <span class="math inline">a\in (A_0\sqcup A_1)^2</span>. The pair <span class="math inline">a = (a_0,a_1)</span> corresponds to the function with <span class="math inline">a(0) = (0,a_0)</span> and <span class="math inline">a(1) = (1,a_1)</span>. Note that not every function in <span class="math inline">(A_0\sqcup A_1)^2</span> corresponds to a pair unless <span class="math inline">A_0 = A_1</span>.</p>
<p><strong>Exercise</strong>. <em>Show <span class="math inline">A^2</span> is in one-to-one correspondence with <span class="math inline">A\times A</span></em>.</p>
<p>The disjoint union <span class="math inline">\sqcup X_I = \sqcup_{i\in I}(\{i\}\times X_i)</span> has inclusions <span class="math inline">\nu_i\colon X_i\to \sqcup X_I</span> where <span class="math inline">\nu_i(x_i) = (i, x_i)</span>.</p>
<p>An element <span class="math inline">x\in\Pi X_I</span> corresponds to a function <span class="math inline">I\to\sqcup X_I</span> where <span class="math inline">x(i) = (i,\pi_i(x))</span>. An element <span class="math inline">x\in\sqcup X_I</span> corresponds to a function <span class="math inline">I\to\sqcup X_I</span> where <span class="math inline">x(i) = (i, x_i)</span>.</p>
<p>Elements of a product are <em>tuples</em>. If all the sets in the product are the same we call the element an <em>array</em>. They are sometimes called vectors, but that collides with the term for elements of a vector space.</p>
<p>If <span class="math inline">J\subseteq I</span> let <span class="math inline">\pi_{J}\colon X_I\to X_J</span> be the <em>projection</em> that selects elements of <span class="math inline">J</span>. If <span class="math inline">I = n</span> we write <span class="math inline">\pi_j</span> instead of <span class="math inline">\pi_{\{j\}}</span> for <span class="math inline">j\in n</span>. A <em>pointed set</em> is a set <span class="math inline">X</span> with a special element <span class="math inline">\star\in X</span>. If the <span class="math inline">X_i</span> are pointed sets we can define the <em>injection</em> <span class="math inline">\nu{J}\colon X_J\to X_I</span> by replacing missing indices with the <span class="math inline">\star</span> for <span class="math inline">X_i</span>, <span class="math inline">i\not\in J</span>. In APL this is written using the <em>backslash</em> operator <span class="math inline">J\setminus = \nu</span>.</p>
<p>A <em>data type</em> is a set <span class="math inline">X</span> together with a collection of operations involving <span class="math inline">X</span>. We assume <span class="math inline">X</span> is finite in what follows since we are concerned with computer implementation. Given data types from some index set <span class="math inline">X_i</span>, <span class="math inline">i\in I</span>, their cartesian product is <span class="math inline">X_I = \Pi_{i\in I}X_i</span>. The projections <span class="math inline">\pi_i\colon X_I\to X_i</span> are defined by <span class="math inline">\pi_i(x) = x_i</span> for <span class="math inline">x\in X_I</span>.</p>
<h2 id="one-dimension">One Dimension</h2>
<h3 id="sequence">Sequence</h3>
<p>The set of all sequences from <span class="math inline">X</span> is <span class="math inline">X^* = \cup_{n\in \bm{N}} X^n</span>. Each element has the form <span class="math inline">(x_0,\ldots,x_{n-1})</span> for <span class="math inline">x_i\in X</span> but it does not necessarily mean all elements are stored somewhere. The unary operator <code>?:X^* -&gt; bool</code> tests if a seqence is not empty. The binary operator <code>@</code> returns the first element of the sequence. More generally, <code>@:N x X^* -&gt; X</code> returns the <span class="math inline">n</span>-th element and is called <em>pick</em>. Its default argument is <code>0</code>. Use <code>n @</code> to return the <span class="math inline">n</span>-th element. The operator <code>&lt;</code> removes the first element of the sequence and is called <em>take</em>. Use <code>n &lt;</code> to remove the first <span class="math inline">n</span> elements.</p>
<p>Let <code>s:N -&gt; N</code>, then <code>xs</code> is <code>xs(i) = x(s(i))</code>.</p>
<h3 id="iota">Iota</h3>
<p>We have been using the convention that the natural number <span class="math inline">n</span> represents the set <span class="math inline">\{0,1,\ldots,n-1\}</span>. In APL this is given the name <span class="math inline">\iota n</span>.</p>
<p>The function <em>take</em> is $X^{n}X</p>
<p>A table <span class="math inline">R\in X^n</span> is <em>one dimensional</em>. The projections <span class="math inline">\pi_i</span> select elements from <span class="math inline">R</span>. In APL <span class="math inline">\pi_i x = x_i</span> is written <span class="math inline">x[i]</span>. Elements of <span class="math inline">R</span> can be <em>taken</em> from the front or back using projections. The table <span class="math inline">R|_{m} = (x_1,\ldots,x_m</span> is the pro</p>
<h1 id="reduce">Reduce</h1>
<p>If a data type <span class="math inline">X</span> is an <em>abelian monoid</em> then we can define a measure on the <span class="math inline">\mathcal{P}(X)</span> by <span class="math inline">\oplus(\{x_j\}) = \oplus_j x_j</span> where <span class="math inline">\oplus</span> is the binary monoid operation and <span class="math inline">\oplus(\emptyset) = 0</span> is the identity element of the monoid. Monoids are pointed sets with their identity being the special element.</p>
<p>Every abelian group is a moniod if we ignore the condition that groups are required to have inverses. Monoids are only required to have an associative and commutative binary operation, and an identity element. Addition and multiplication of numbers are abelian groups. The set <span class="math inline">[-\infty,\infty)</span> with binary operation <span class="math inline">x\vee y = \max\{x,y\}</span> is an abelian monoid with identity <span class="math inline">-\infty</span>. Similarly, <span class="math inline">(-\infty,\infty]</span> with <span class="math inline">x\wedge y = \min\{x,y\}</span> and identity <span class="math inline">\infty</span> is an abelian monoid.</p>
<p><strong>Exercise</strong>. <em>Show <span class="math inline">\oplus(\{s_j\}) = \oplus_j s_j</span> is a well-defined measure on <span class="math inline">X</span></em>.</p>
<p>Technically we should write this as <span class="math inline">\oplus(\{(j, s_j)\}) = \oplus_j s_j</span> to avoid collapsing set elements.</p>
<p>Hint: Since monoid operations are associative and commutative <span class="math inline">\oplus(\{x_1,\ldots,x_n\}) = x_1\oplus\cdots\oplus x_n</span> is well-defined. You need to show <span class="math inline">\oplus(U\cup V) = (\oplus(U))\oplus(\oplus(V))</span> if <span class="math inline">U\cap V = \emptyset</span> for <span class="math inline">U,V\subseteq X</span>. Start with <span class="math inline">\oplus(U\cup \emptyset) = \oplus(U) = (\oplus(U))\oplus 0 = (\oplus(U))\oplus(\oplus\emptyset)</span> and use induction on the number of elements of <span class="math inline">V</span>.</p>
<p>If <span class="math inline">R\in X^n</span> then <span class="math inline">\oplus R</span> is an element of <span class="math inline">X</span>. If <span class="math inline">R\in X_I^n</span> is a table and <span class="math inline">X_i</span> is an abelian monoid we can apply its operation at index <span class="math inline">i</span> to get <span class="math inline">\oplus_i R\in X_I^n</span> where the rows of <span class="math inline">R</span> have their <span class="math inline">i-th</span> component replaced by the constant value <span class="math inline">\oplus R_{\{i\}}</span>. This is called <em>reduction</em> along column <span class="math inline">i</span> and in APL it is written using the <em>forward slash</em> operator <span class="math inline">\oplus_i/R</span>.</p>
<h2 id="expand">Expand</h2>
<p>If an abelian monoid has a total ordering that is discrete with elements $0 = x_0 &lt; x_1 &lt; $ define $<span class="math inline">X^\infty</span> by <span class="math inline">\iota n = (x_0,\ldots,x_n)</span>.</p>
<h2 id="notation">Notation</h2>
<p>tuple <span class="math inline">\Pi_{i\in I} X_i\subseteq (\sqcup_{i\in I} X_i)^I</span>.</p>
<p>projection <span class="math inline">\pi_i\colon\Pi_{i\in I} X_i\to X_i</span> where <span class="math inline">\pi_i(x) = x_i</span>.</p>
<p>array <span class="math inline">X^I</span></p>
<h2 id="remarks">Remarks</h2>
<p>A pair <span class="math inline">(a,b)</span> must satisfy the property <span class="math inline">(a,b) = (c,d)</span> if and only if <span class="math inline">a = c</span> and <span class="math inline">b = d</span>. Everything in mathematics is a set. What set is the pair <span class="math inline">(a,b)</span>? This is a subtle problem with no unique solution. Kuratowski defined it to be the set <span class="math inline">\langle a,b\rangle = \{\{a\},\{a,b\}\}</span>. Clearly if <span class="math inline">a = c</span> and <span class="math inline">b = d</span> then <span class="math inline">\langle a,b\rangle</span> and <span class="math inline">\langle c,d\rangle</span> are equal sets. The other direction is not so trivial. If <span class="math inline">a = b</span> then <span class="math inline">\langle a,b\rangle =\{\{a\},\{a,a\}\} = \{\{a\},\{a\}\} = \{\{a\}\}</span> so <span class="math inline">\langle c,d\rangle</span> must be a singleton and <span class="math inline">\{c\} = \{c,d\}</span>. This can only be true if <span class="math inline">c = d</span>, hence <span class="math inline">\{a\} = \{c\}</span> and <span class="math inline">a = c</span>.</p>
<p><strong>Exercise</strong>. <em>Prove the case <span class="math inline">a\not= b</span></em>.</p>
<p>Category Theory uses <em>objects</em> and <em>arrows</em> instead of sets. The <em>product</em> of sets is defined in terms of objects and arrows. An object <span class="math inline">C</span> with arrows <span class="math inline">p\colon C\to A</span> and <span class="math inline">q\colon C\to B</span> is the product of <span class="math inline">A</span> and <span class="math inline">B</span> if and only if for every object <span class="math inline">D</span> having arrows <span class="math inline">r\colon D\to A</span> and <span class="math inline">s\colon D\to B</span> there exists an arrow <span class="math inline">t\colon D\to C</span> with <span class="math inline">rt = p</span> and <span class="math inline">st = q</span>. The product is unique up to isomorphism.</p>
<p>Objects do not have elements in Category Theory, everything must be defined in terms of objects and arrows. In the category Set we can define all subsets of the object <span class="math inline">S</span> as <span class="math inline">\hom(S,\{0,1\})</span>, the arrows <span class="math inline">a\colon S\to\{0,1\}</span>. The arrow corresponds to the subset <span class="math inline">A = \{s\in S:a(s) = 1\}</span>.</p>
<p>A <em>terminal object</em> is an object that always has exactly one arrow from any other object. In category Set the terminal objects are singletons and the corresponding arrow can be thought of as selecting an element from its domain. If <span class="math inline">a\in\hom(S,\{0,1\})</span> is terminal then it corresponds to picking one element from <span class="math inline">A</span>.</p>
<p>The “pairs” of <span class="math inline">C</span> are terminal objects having domain <span class="math inline">C</span>. Let <span class="math inline">t\colon C\to T</span> and <span class="math inline">t&#39;\colon C\to T&#39;</span> be the unique arrows for <span class="math inline">T</span> and <span class="math inline">T&#39;</span>. We also have unique arrows <span class="math inline">a\colon A\to T</span>, <span class="math inline">a&#39;\colon A\to T&#39;</span> and <span class="math inline">b\colon B\to T</span>, <span class="math inline">b&#39;\colon B\to T&#39;</span>. Since <span class="math inline">ap\colon C\to T</span> and <span class="math inline">a&#39;p\colon C\to T</span> we have <span class="math inline">ap = a&#39;p</span>. Likewise <span class="math inline">bq = b&#39;q</span>.</p>
<p>…product as terminal object…</p>
<footer>
Return to <a href="index.html">index</a>.
</footer>
</body>
</html>
