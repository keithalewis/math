<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Keith A. Lewis" />
  <title>Coroutines</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="math.css" />
  <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      fleqn: true
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Coroutines</h1>
<p class="author">Keith A. Lewis</p>
</header>
<p>A <em>coroutine</em> is a function and a <em>continuation point</em>. Unlike functions, coroutines can suspend execution and resume at a later time. The continuation point keeps track of where the coroutine was last suspended.</p>
<p>Coroutines make it far easier to write concurrent code than using threads. Unlike threads, coroutines are suspended at function statements instead of being preempted between some recondite machine instruction by the system thread scheduler. There is no need to orchestrate the creation and collection of threads and then sprinkle the code with mutexes or semaphores in the hope of ensuring correct program execution.</p>
<p>Like functions, coroutines can stand on their own. What they add is the ability to cooperate with other coroutines to share the task of code execution.</p>
<p>Producer and consumer coroutines can cooperate to send items through a queue.</p>
<pre><code>coroutine produce
    loop
        while queue not full
            add items to queue
        yield to consume

coroutine consume
    loop
        while queue not empty
            remove items from queue
        yield to produce</code></pre>
<p>There is no need for multiple theads; yield can jump directly from one coroutine to another.</p>
<p>Another common use is to generate unbounded streams of data.</p>
<pre><code>coroutine iota
    i = 0
    loop
        yield i
        i = i + 1</code></pre>
<p>The first time the coroutine is called a counter is set to 0. The first pass through the loop sets the statement after yield as the continuation point and returns 0. The next time it is resumed the counter is incremented and the second pass through the loop sets a new continuation point and returns 1. Rinse and repeat.</p>
<h2 id="the-life-of-a-coroutine">The Life of a Coroutine</h2>
<p>When a coroutine is created the continuation point is set to the beginning of the routine and it is put in a suspended state. Calling the coroutine with its arguments resumes exectution from the beginning. If the function contains a yield statement then the continuation point is set to the next statement in the function and execution is suspended. The arguments to yield become the result of the resume that activated the coroutine. Subsequent calls of the coroutine resume execution at the coninuation point and the arguments of the call become available to the coroutine. Execution continues until the next yield statement and the above is repeated or until the function terminates and the return values become the result of the last reactivation. At that point the coroutine can no longer be resumed.</p>
<h2 id="theory">Theory</h2>
<p>A <em>full asymmetric coroutine</em> has three operations: <em>create</em>, <em>resume</em>, and <em>yield</em>. Create takes a coroutine body and instanciates it in a suspended state. The <em>continuation point</em> is set to the beginning of the body. Resume cause a coroutine to execute from its continuation point until it either yields at a new continuation point or terminates. A terminated coroutine cannot be resumed.</p>
<p>The first call to resume specifies the coroutine parameters. In subsequent calls to resume these become the result of yield. When a coroutine suspends, the arguments to yield become the result of the resume that activated the coroutine. When a coroutine terminates, the values returned by the body become the result of the last reactivation.</p>
<p>An <em>expression</em> is a <em>lable</em>, <em>variable</em>, <em>function</em>, <em>application</em>, variable assignment, <em>conditional</em>, equality operator for labels, or a <em>nil</em> value.</p>
<p><span class="math inline">e \to l\mid v\mid x\mapsto e\mid e\,e\mid x := e\mid e\,?\,e : e\mid e = e\mid \bot</span></p>
<p>A value is a label, function, or nil.</p>
<p>A <em>store</em> is a mapping from variables and labels to values. <span class="math inline">\theta\colon\mathit{variables}\cup\mathit{labels}\to\mathit{values}</span></p>
<p>An <em>evaluation context</em> is used to specify evaluaton of <em>expressions</em>.</p>
<p><span class="math display">
C \to \emptyset\mid e C\mid C v\mid x := C\mid  C\,?\,e : e\mid e = C\mid C = v
</span></p>
<p>A context and a store is evaluated to a value. <span class="math display">
\begin{aligned}
    \langle C[x],\theta\rangle &amp;\Rightarrow \langle C[\theta(x)],\theta\rangle \\
    \langle C[(x\mapsto e)v],\theta\rangle &amp;\Rightarrow \langle C[e[z/x]],\theta[z\leftarrow v]\rangle \\
    \langle C[x := v],\theta\rangle &amp;\Rightarrow \langle C[v],\theta[x\leftarrow v]\rangle \\
    \langle C[\bot\,?\,e_1 : e_2],\theta\rangle &amp;\Rightarrow \langle e_2,\theta\rangle \\
    \langle C[v\,?\,e_1 : e_2],\theta\rangle &amp;\Rightarrow \langle e_1,\theta\rangle \\
    \langle C[l = l],\theta\rangle &amp;\Rightarrow \langle C[l],\theta\rangle \\
    \langle C[l_1 = l_2],\theta\rangle &amp;\Rightarrow \langle C[\bot],\theta\rangle \\
\end{aligned}
</span></p>
<p>Expressions can be labeled and used in coroutine operators.</p>
<p><span class="math display">
e \to \dots\mid l:e\mid \mathbf{create}\,e\mid \mathbf{resume}\,e\,e\mid \mathbf{yield}\,e
</span></p>
<footer>
Return to <a href="index.html">index</a>.
</footer>
</body>
</html>
