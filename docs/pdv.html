<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Keith A. Lewis" />
  <meta name="dcterms.date" content="2025-01-26" />
  <title>Path Dependent Volatility</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="math.css" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: true
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Path Dependent Volatility</h1>
<p class="author">Keith A. Lewis</p>
<p class="date">January 26, 2025</p>
<div class="abstract">
<div class="abstract-title">Abstract</div>
Volatility is path dependent.
</div>
</header>
<p>When a trader sets up an initial hedge for an option they usually
come up with a volatility to plug into the Black-Scholes/Merton formula
for delta. As time goes by they rehedge using the formula for gamma. If
stock prices were geometric Brownian motion generated by a computer then
the same volatility could be used over the life of the option. Of course
they are not, so traders might observe underlying stock prices over time
and update their volatility guess based on that. In this case the
volatility is <em>path dependent</em>.</p>
<p>The B-S/M model assumes stock prices satisfy <span
class="math inline">dS_t/S_t = \mu\,dt + \sigma\,dB_t</span> where <span
class="math inline">\mu</span> and <span
class="math inline">\sigma</span> are constant and <span
class="math inline">(B_t)_{t\ge0}</span> is standard Brownian motion.
The Ito calculus shows <span class="math inline">(dS_t/S_t)^2 =
\sigma^2\,dt</span> so a natural extension to path dependent volatility
might be <span class="math inline">dS_t/S_t = \mu\,dt +
\Sigma_t\,dB_t</span> with <span class="math inline">{\Sigma_t^2 =
(1/t)\int_0^t (dS/S)^2}</span>. The volatility <span
class="math inline">\Sigma</span> is the average of the realized
volatility. Unfortunately, this is not a good model since it implies
<span class="math inline">\Sigma</span> is constant. Since <span
class="math inline">t\Sigma_t^2 = \int_0^t (dS/S)^2 = \int_0^t
\Sigma_s^2\,ds</span> we have <span class="math inline">d(t\Sigma_t^2) =
\Sigma_t^2</span>. By the Ito calculus we also have <span
class="math inline">d(t\Sigma_t^2) = t\,d\Sigma^2_t +
\Sigma_t^2\,dt</span> so <span class="math inline">0 =
t\,d\Sigma_t^2</span> and <span class="math inline">\Sigma_t</span> must
be constant.</p>
<p>The average realized volatility assigns equal weight to each
observation. If <span class="math inline">K</span> is a function on the
positive real numbers then we can consider <span class="math display">
    \Sigma^2_t = \int_0^t K(t - s)(d\Sigma_s/\Sigma_s)^2\,ds
</span> It makes sense to assign more weight to recent observations so
we can choose <span class="math inline">K</span> to be a decreasing
function, e.g., <span class="math inline">K(t) = \lambda\exp(-\lambda
t)</span>, <span class="math inline">t &gt; 0</span>, for some positive
<span class="math inline">\lambda\in\boldsymbol{R}</span>. Note <span
class="math inline">\int_0^\infty K(t)\,dt = 1</span>. This can be
generalized to integrals of the form <span class="math display">
    \int_0^t K(t - s)\phi(d\Sigma_s/\Sigma_s)\,ds
</span> for some function <span class="math inline">\phi</span>. Note
this is scale-invariant in <span class="math inline">\Sigma_t</span>. We
may want to normalize <span class="math inline">K</span> by dividing by
<span class="math inline">\int_0^t K(t - s)\,ds</span>.</p>
<p>Guyon and Lekeufack define <span class="math inline">{R_{j,t} =
\int_0^t K(t - s)(d\Sigma_s/\Sigma_s)^j\,ds}</span> for <span
class="math inline">j = 1, 2</span>. Their model for fitting volatility
is <span class="math display">
    \Sigma_t = \beta_0 + \beta_1 R_{1,t} + \beta_2 \sqrt{R_{2,t}},
\qquad \beta_0 &gt; 0, \beta_1 &lt; 0, \beta_2\in (0,1).
</span></p>
<p>The paper is not clear on how data are used to produce the <span
class="math inline">R_j</span>. VIX data are 30-day vols and implied
volatility can be obtained from option prices, but at what
maturities?</p>
<p>A fundamental flaw in the paper is the authors seeming to be unaware
that any model that fits European options automatically fits the
VIX.</p>
<p>“Beyond the ability to produce desired spot-vol dynamics and capture
spot-vol historical patterns, an important criterion to assess the
quality of a PDV model should be its hedging performance on backtests, a
task we leave for future work.”</p>
</body>
</html>
