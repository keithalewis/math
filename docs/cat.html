<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Keith A. Lewis" />
  <title>Category Theory</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="math.css" />
  <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      fleqn: true
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Category Theory</h1>
<p class="author">Keith A. Lewis</p>
</header>
<blockquote>
<p><em>Besides it is an error to believe that rigour is the enemy of simplicity. On the contrary we find it confirmed by numerous examples that the rigorous method is at the same time the simpler and the more easily comprehended. The very effort for rigor forces us to find out simpler methods of proof. — David Hilbert</em></p>
</blockquote>
<p>A <em>category</em> consists of <em>objects</em> and <em>arrows</em> that can sometimes be <em>composed</em>. Arrows that can be composed are <em>associative</em>. Every object has an <em>identity arrow</em>.</p>
<p>The canonical example of a category is <span class="math inline">\mathbf{Set}</span> with objects sets and arrows functions. Every <em>preset</em> is a category in <span class="math inline">\mathbf{Pre}</span> with arrows <span class="math inline">a\to b</span> whenever <span class="math inline">a\preceq b</span>. The reflexive and transitive laws corresponds to identity arrows and composition. The associative law follows from there being at most one arrow between any two objects. Categories with exactly one object are in <span class="math inline">\mathbf{Mon}</span>. The identity and associative laws of categories correspond to the axioms of a monoid.</p>
<h2 id="objects-and-arrows">Objects and Arrows</h2>
<p>An <em>arrow</em> <span class="math inline">f</span> from <em>object</em> <span class="math inline">A</span> to object <span class="math inline">B</span> is written <span class="math inline">f\colon A\to B</span>.</p>
<p>The <em>domain</em> of <span class="math inline">f</span> is <span class="math inline">\operatorname{dom}f = A</span> and the <em>codomain</em> of <span class="math inline">f</span> is <span class="math inline">\operatorname{cod}f = B</span> The codomain is also called <em>range</em>, <em>target</em>, or <em>but</em> if you parlez Français.</p>
<p>We could do away with objects use the domain and codomain of arrows, just as it is possible to use nand to define all other logical operators, but why make things more difficult?</p>
<p>The “set” of arrows from <span class="math inline">A</span> to <span class="math inline">B</span> is called <span class="math inline">\hom(A,B)</span>. The scare quotes indicate this is not necessarily a set but standard terminology for this is <em>homset</em>.</p>
<h2 id="composition">Composition</h2>
<p>If <span class="math inline">f\colon A\to B</span> and <span class="math inline">g\colon B\to C</span> then there exists an arrow <span class="math inline">g \circ f\colon A\to C</span>, the <em>composition</em> of <span class="math inline">g</span> with <span class="math inline">f</span>. One of the axioms of category theory is that if the codomain of <span class="math inline">f</span> equals the domain of <span class="math inline">g</span>, then the composition exists.</p>
<p>Since we will be doing a lot of composing we just write <span class="math inline">gf</span> instead of <span class="math inline">g \circ f</span>. Some people prefer to use <span class="math inline">f;g</span> instead of <span class="math inline">gf</span>. In this notation <span class="math inline">f\colon A\to B</span> and <span class="math inline">g\colon B\to C</span> compose to <span class="math inline">f;g\colon A\to C</span> keeping the arrow names in order. If this sort of trifling is a concern you can just write the arrows backwards: <span class="math inline">g\colon C\leftarrow B</span> and <span class="math inline">\colon\colon B\leftarrow A</span> so <span class="math inline">gf\colon C\leftarrow A</span>.</p>
<h2 id="identity-arrow">Identity Arrow</h2>
<p>On to more interesting things. Every object has an <em>identity arrow</em>. If <span class="math inline">f\colon A\to B</span> then the identity arrows <span class="math inline">1_A\colon A\to A</span> and <span class="math inline">1_B\colon B\to B</span> satisfy <span class="math inline">f 1_A = f = 1_B f</span>. Or maybe only somewhat more interesing. You can always throw in identity arrows if they don’t exist.</p>
<h3 id="exercises">Exercises</h3>
<p><strong>Excercise</strong>. <em>If <span class="math inline">e\colon A\to A</span> has the property <span class="math inline">fe = f</span> for all <span class="math inline">f\colon A\to B</span> then <span class="math inline">e = 1_A</span></em>.</p>
<p><strong>Excercise</strong>. <em>If <span class="math inline">e\colon B\to B</span> has the property <span class="math inline">ef = f</span> for all <span class="math inline">f\colon A\to B</span> then <span class="math inline">e = 1_B</span></em>.</p>
<h2 id="associative-law">Associative Law</h2>
<p>If <span class="math inline">f\colon A\to B</span>, <span class="math inline">g\colon B\to C</span>, and <span class="math inline">h\colon C\to D</span> then we have arrows <span class="math inline">gf</span>, <span class="math inline">hg</span>, <span class="math inline">h(gf)</span>, and <span class="math inline">(hg)f</span>. The <em>associative law</em> states <span class="math inline">(hg)f = h(gf)</span> so <span class="math inline">hgf</span> is unambiguous in category theory.</p>
<p>A collection of objects and arrow satisfying these laws is a <em>category</em>.</p>
<h2 id="isomorphic">Isomorphic</h2>
<p>A key concept in category theory is <em>isomorphism</em>. Two objects <span class="math inline">A</span> and <span class="math inline">B</span> are isomorphic if there exist arrows <span class="math inline">f\colon A\to B</span> and <span class="math inline">g\colon B\to A</span> with <span class="math inline">fg = 1_B</span> and <span class="math inline">gf = 1_A</span> and we write <span class="math inline">A\cong B</span>. If <span class="math inline">A=B</span> then <span class="math inline">1_A = f = g = 1_B</span> demonstrates <span class="math inline">A</span> and <span class="math inline">A</span> are isomorphic.</p>
<p><strong>Exercise</strong>. <em>Show isomorphism is an equivalence relation</em>.</p>
<p>Hint: We have shown <span class="math inline">A\cong A</span> for every object <span class="math inline">A</span>. Show <span class="math inline">A\cong B</span> implies <span class="math inline">B\cong A</span> and <span class="math inline">A\cong B</span>, <span class="math inline">B\cong C</span> imply <span class="math inline">A\cong C</span>.</p>
<p>Think of equivalence as a weakened form of equality. In the case of <span class="math inline">\mathbf{Set}</span> it is a very weakened form. Adding structure to sets by reducing the number of functions creates finer grained equivalence relations.</p>
<p>We call <span class="math inline">f,g</span> an <em>isomorphism pair</em> for <span class="math inline">A,B</span>. If <span class="math inline">f,g</span> and <span class="math inline">f,g&#39;</span> are isomporphims pairs for <span class="math inline">A,B</span> then <span class="math inline">g = g&#39;</span> since <span class="math inline">g = g1_B = g(fg&#39;) = (gf)g&#39; = 1_Ag&#39; = g&#39;</span>. We write <span class="math inline">g = f^{-1}</span> and, mutatis mutandis, <span class="math inline">f = g^{-1}</span>.</p>
<p><strong>Exercise</strong>. <em>Show two sets in <span class="math inline">\mathbf{Set}</span> are isomorphic if and only if they have the same cardinality</em>.</p>
<p>This also shows isomorphism pairs are not, in general, unique.</p>
<h2 id="examples">Examples</h2>
<p>It is impossible to understand category theory without understanding examples of categories. They are its raison d’être. Many seemingly disparate constructs can be unified.</p>
<p>The canonical example of a category is <span class="math inline">\mathbf{Set}</span>. The objects are sets and the arrows are functions. People tried to come up with a purely category theory notion of <span class="math inline">\mathbf{Set}</span> and ended up with <em>topos theory</em>. One does not simply consider ‘elements’ of a ‘set’. Composition is standared function composition, which is associative. The identity arrows are the identity functions <span class="math inline">1_A\colon A\to A</span> by <span class="math inline">1_A(a) = a</span> for <span class="math inline">a\in A</span>.</p>
<p>Then there is <span class="math inline">\mathbf{Par}</span>, the category of partial functions. It does not get the respect it deserves. Most functions are actually partial functions. The function <span class="math inline">x\mapsto 1/x</span> is only a partial function from the real numbers to the real numbers. The partial functions <span class="math inline">f\colon A\to B</span> and <span class="math inline">g\colon B\to C</span> can be composed using <span class="math inline">gf(a) = c</span> if and only if there exists <span class="math inline">b\in B</span> with <span class="math inline">f(a) = b</span> and <span class="math inline">g(b) = c</span>. It has the same identity arrows as <span class="math inline">\mathbf{Set}</span>.</p>
<p>A case could be made that <span class="math inline">\mathbf{Set}</span> should be called <span class="math inline">\mathbf{Fun}</span>.</p>
<p><span class="math inline">\mathbf{Rel}</span> is the category of relations. It generalizes <span class="math inline">\mathbf{Set}</span> and <span class="math inline">\mathbf{Par}</span>.</p>
<h3 id="sets-with-structure">Sets with Structure</h3>
<p>There are a slew of examples of categories where the objects are sets ‘with structure’ and the arrows are functions that preserve that structure.</p>
<p>We have already seen <span class="math inline">\mathbf{Mon}</span>, categories having exactly one object.</p>
<p><span class="math inline">\mathbf{Grp}</span> is the category of groups; the objects are groups and the arrows are <em>homomorphisms</em>, functions that preserve the group structure.</p>
<p><span class="math inline">\mathbf{Vec}</span> is the category of vector spaces; the objects are vector spaces and the arrows are linear transformations.</p>
<p>Rings, fields, and algebras provide more examples. The theme of category theory is to provide a unified treatment of various mathematical areas.</p>
<!--
All of these examples satisfy a lemma of the form every arrow
$f\colon A\to B$ is a composition of arrows
$\pi\colon A\to A/\ker f$, $\nu\colon A/\ker f\to \ran B$, and $i\colon \ran B\to B$
where $\pi$ is 'onto' and $\nu$ is 'one-to-one'
for appropriate definitions of $\ker$, $\ran$, quotient $/$,
onto, and one-to-one. Arrows can be used to factor objects into smaller
objects $A/\ker f$ and $\ran f$. This is similar to factoring a number
into primes.
-->
<h3 id="orders">Orders</h3>
<p><span class="math inline">\mathbf{Pre}</span> is the category of <em>presets</em>. A preset is a set wtih a relation <span class="math inline">\preceq</span> that is reflexive (<span class="math inline">a\preceq a</span>) and transitive (<span class="math inline">a\preceq b</span> and <span class="math inline">b\preceq c</span> imply <span class="math inline">a\preceq b</span>). Such relations are called <em>preorders</em>. Presets long predate categories, but this maps perfectly into the the definition of a category. The objects are elements of the set and there is an arrow <span class="math inline">x\to y</span> if and only if <span class="math inline">x \preceq y</span>. The identity arrow is the reflexive property and composition is the transitive law. Preorders have the property that homsets have at most one arrow. Every category with this property is a preset.</p>
<p><span class="math inline">\mathbf{Pos}</span> is the category of <em>posets</em>. A <em>poset</em> is a preset that is also <em>antisymmetric</em> (<span class="math inline">a\preceq b</span> and <span class="math inline">b\preceq a</span> imply <span class="math inline">a = b</span>). Such relations are called <em>partial orders</em>. The category <em>Set</em> can be viewed as a poset under subset inclusion. The objects are sets and the arrows are <span class="math inline">f\colon A\to B</span> if <span class="math inline">A\subseteq B</span>.</p>
<p><span class="math inline">\mathbf{Equ}</span> is the category of <em>equivalence relations</em>. An equivalence relations is a preorder that is also <em>symmetric</em> (<span class="math inline">a\preceq b</span> implies <span class="math inline">b\preceq a</span>). Equivalence relations are used to classify objects.</p>
<h3 id="mathbfcat"><span class="math inline">\mathbf{Cat}</span></h3>
<p><span class="math inline">\mathbf{Cat}</span> is the category of categories. The objects are categories and the arrows are <em>functors</em>.</p>
<p>A functor from category <span class="math inline">C</span> to category <span class="math inline">D</span> takes objects of <span class="math inline">C</span> to objects of <span class="math inline">D</span> and arrows of <span class="math inline">C</span> to arrows of <span class="math inline">D</span> and preserves the category structure:</p>
<ol type="i">
<li>If <span class="math inline">f\colon A\to B</span> in <span class="math inline">C</span> then <span class="math inline">F(f)\colon F(A)\to F(B)</span> in <span class="math inline">D</span>.<br />
</li>
<li>If <span class="math inline">g\colon A\to B</span> and <span class="math inline">h\colon B\to C</span> in <span class="math inline">C</span> then <span class="math inline">F(hg) = F(h)F(g)</span> in <span class="math inline">D</span>.</li>
</ol>
<p><strong>Excercise</strong>. <em>What is the identity functor?</em></p>
<p><strong>Excercise</strong>. <em>Show composition of functors is associative</em>.</p>
<p>You may now be wondering if there is a category of category of categories. There is and it is called <span class="math inline">2</span>-<span class="math inline">\mathbf{Cat}</span>. The objects are functors and the arrows are <em>natural transformations</em>.</p>
<p>A natural transformation, <span class="math inline">\eta\colon F\to G</span>, of functors <span class="math inline">F,G\colon\mathbf{C}\to\mathbf{D}</span> takes objects of <span class="math inline">\mathbf{C}</span> to arrows of <span class="math inline">\mathbf{D}</span>. If <span class="math inline">h\colon A\to B</span> in <span class="math inline">\mathbf{C}</span> then <span class="math inline">F(h)\colon F(A)\to F(B)</span> and <span class="math inline">G(h)\colon G(A)\to G(B)</span> in <span class="math inline">\mathbf{D}</span>. The arrows <span class="math inline">\eta_A\colon F(A)\to G(A)</span> and <span class="math inline">\eta_B\colon G(A)\to G(B)</span> in <span class="math inline">\mathbf{D}</span> satisfy <span class="math inline">\eta_A F(h) = G(h)\eta_B</span>.</p>
<p>The prototypical example of natural transformation arises in the category <span class="math inline">\mathbf{Vec}</span>. The <em>dual</em> of a vector space is <span class="math inline">V^* = \hom(V,\mathbf{F})</span> where <span class="math inline">\mathbf{F}</span> is the underlying field of the vector space. The <em>dual pairing</em> between <span class="math inline">V</span> and <span class="math inline">V^*</span> is <span class="math inline">\langle v,v^*\rangle = v^*(v)</span>. If <span class="math inline">T\colon V\to W</span> is a linear transformation then <span class="math inline">T^*\colon W^*\to V^*</span> via <span class="math inline">\langle Tv,w^*\rangle = \langle v,T^*w^*\rangle</span>. Note <span class="math inline">T^{**}\colon V^{**}\to W^{**}</span> and gives rise to a functor <span class="math inline">D</span> in <span class="math inline">\mathbf{Vec}</span> via <span class="math inline">V\mapsto V^{**}</span> and <span class="math inline">T\mapsto T^{**}</span>. There is a natural inclusion <span class="math inline">\iota_V\colon V\to V^{**}</span> by <span class="math inline">\langle \iota_V v,v^*\rangle = \langle v, v^*\rangle</span>. The property <span class="math inline">T^{**}\iota_V = \iota_W T</span> says <span class="math inline">\iota\colon I\to D</span> is a natural transformation where <span class="math inline">I</span> is the identity functor of <span class="math inline">\mathbf{Vec}</span>.</p>
<p><strong>Exercise</strong>. <em>Show <span class="math inline">T^{**}\iota_V = \iota_W T</span></em>.</p>
<details>
<p><summary>Solution</summary></p>
<blockquote>
<p>For <span class="math inline">v\in V</span> and <span class="math inline">w^*\in W^*</span>, <span class="math inline">\langle T^{**}\iota_V v,w^*\rangle =\langle \iota_V v,T^*w^*\rangle =\langle v,T^*w^*\rangle =\langle Tv,w^*\rangle =\langle \iota_W Tv,w^*\rangle</span>.</p>
</blockquote>
</details>
<p>Are there categories of categories of …? Yep. They are called <span class="math inline">n</span>-<span class="math inline">\mathbf{Cat}</span>. It’s categories all the way down.</p>
<h2 id="arrows">Arrows</h2>
<p>Although <span class="math inline">\mathbf{Set}</span> is a prototypical example of a category you will need to disabuse yourself of the notion objects have elements. Everything in category theory must be expressed in terms of objects and arrows. Attempts to express <span class="math inline">\mathbf{Set}</span> purely in terms of objects and arrows leads to <span class="math inline">\mathbf{Top}</span>, the category of topoi. This attempt failed in the sense that it did not lead back to the category <span class="math inline">\mathbf{Set}</span>. It was succesful at giving a better understanding of the foundations of mathematics. Unfortunately, as often happens in mathematics, following your nose leads to complications. For example, a sphere is a set. The elements of the set are points on the sphere. In a topoi the “elements” of the sphere are the tangent planes to each point.</p>
<p>We have already seen how to use arrows to define isomorphisms. If <span class="math inline">A</span> and <span class="math inline">B</span> are isomorphic then there are arrows <span class="math inline">f\colon A\to B</span> and <span class="math inline">g\colon B\to A</span> with <span class="math inline">fg = 1_B</span> and <span class="math inline">gf = 1_A</span>. We say <span class="math inline">f\colon A\to B</span> has <em>right inverse</em> <span class="math inline">g\colon B\to A</span> when <span class="math inline">fg = 1_B</span> and <span class="math inline">f</span> has <em>left inverse</em> <span class="math inline">g</span> when <span class="math inline">gf = 1_A</span>.</p>
<p><strong>Exercise</strong>. <em>If <span class="math inline">f</span> has right inverse <span class="math inline">g</span> and left inverse <span class="math inline">g&#39;</span> show <span class="math inline">g = g&#39;</span></em>.</p>
<details>
<p><summary>Solution</summary></p>
<blockquote>
<p>We have <span class="math inline">g&#39; = g&#39;1_B = g&#39;(fg) = (g&#39;f)g = 1_Ag = g</span>.</p>
</blockquote>
</details>
<p>This shows an arrow with both a right and left inverse is an isomorphism.</p>
<p>If <span class="math inline">fh = fk</span> implies <span class="math inline">h = k</span> then <span class="math inline">f</span> is called <em>mono</em>. If <span class="math inline">f</span> has a right inverse and <span class="math inline">h,k\colon B\to C</span> satisfy <span class="math inline">hf = kf</span> then <span class="math inline">h = h1_B = hfg = kfg = k1_B = k</span>. Arrows having a right inverse are mono.</p>
<p>If <span class="math inline">hf = kf</span> implies <span class="math inline">h = k</span> then <span class="math inline">f</span> is called <em>epi</em>. If <span class="math inline">f</span> has a left inverse and <span class="math inline">h,k\colon C\to A</span> satisfy <span class="math inline">fh = fk</span> then <span class="math inline">h = 1_Ah = gfh = gfk = 1_Ak = k</span>. Arrows having a left inverse are epi.</p>
<p>In <span class="math inline">\mathbf{Set}</span> mono arrows have a left inverse and epi arrows have a right inverse, but this is not true for every category.</p>
<p>An arrow that is both mono and epi is called <em>iso</em>.</p>
<p>!!!</p>
<h2 id="answers-to-exercises">Answers to Exercises</h2>
<p><strong>Excercise</strong>. 1. If <span class="math inline">e\colon A\to A</span> has the property <span class="math inline">fe = f</span> for all <span class="math inline">f\colon A\to B</span> then <span class="math inline">e = 1_A</span>_.</p>
<p><strong>Solution.</strong> Taking <span class="math inline">f = 1_A</span>, <span class="math inline">1_A e = 1_A</span>. By the definition of <span class="math inline">1_A</span>, <span class="math inline">1_A e = e</span>, hence <span class="math inline">1_A = e</span>.</p>
<p><strong>Excercise</strong>. 2. If <span class="math inline">e\colon B\to B</span> has the property <span class="math inline">ef = f</span> for all <span class="math inline">f\colon A\to B</span> then <span class="math inline">e = 1_B</span>_.</p>
<p><strong>Solution</strong> Taking <span class="math inline">f = 1_B</span>, <span class="math inline">e 1_B = 1_B</span>. By the definition of <span class="math inline">1_B</span>, <span class="math inline">e 1_B = e</span>, hence <span class="math inline">1_B = e</span>.</p>
<p><strong>Excercise</strong>. 3. Show the identity arrows of_ Set <em>are <span class="math inline">1_A = {(a,a)\in A\times A \colon a\in A}</span></em>.</p>
<p><strong>Solution</strong> Let <span class="math inline">R\colon A\to B</span> be a relation. The following are equivalent: &gt; <span class="math inline">(a, b)\in 1_A R</span><br />
&gt; There exists <span class="math inline">a&#39; in A</span> with <span class="math inline">(a, a&#39;)\in 1_A</span> and <span class="math inline">(a&#39;, b)\in R</span>.<br />
&gt; <span class="math inline">(a, a)\in 1_A</span> and <span class="math inline">(a, b)\in R</span><br />
&gt; <span class="math inline">(a, b)\in R</span><br />
The proof of <span class="math inline">R 1_B = R</span> is similar.</p>
<p><strong>Excercise</strong>. 4. Show that composition is associative in_ Set.</p>
<p><strong>Solution</strong> Let <span class="math inline">R\colon A\to B</span>, <span class="math inline">S\colon B\to C</span> and <span class="math inline">T:C\to D</span>. The following are equivalent: &gt; <span class="math inline">(a, d)\in (TS)R</span>.<br />
&gt; There exists <span class="math inline">b\in B</span> with <span class="math inline">(a, b)\in R</span> and <span class="math inline">(b, d)\in (TS)</span>.<br />
&gt; There exists <span class="math inline">b\in B</span> with <span class="math inline">(a, b)\in R</span> and there exists <span class="math inline">c\in C</span> with <span class="math inline">(b, c)\in S</span> and <span class="math inline">(c, d)\in T</span>.<br />
&gt; There exists <span class="math inline">b\in B</span> and there exists <span class="math inline">c\in C</span> with <span class="math inline">(a, b)\in R</span> and <span class="math inline">(b, c)\in S</span> and <span class="math inline">(c, d)\in T</span>.<br />
&gt; There exists <span class="math inline">c\in C</span> and there exists <span class="math inline">b\in B</span> with <span class="math inline">(a, b)\in R</span> and <span class="math inline">(b, c)\in S</span> and <span class="math inline">(c, d)\in T</span>.<br />
&gt; There exists <span class="math inline">c\in C</span> with <span class="math inline">(a, c)\in SR</span> and <span class="math inline">(c, d)\in T</span>.<br />
&gt; <span class="math inline">(a, d)\in T(SR)</span>.</p>
<p><strong>Excercise</strong>. 5. Show <span class="math inline">R</span> is reflexive if and only if <span class="math inline">1_A</span> is a subset of <span class="math inline">R</span>_.</p>
<p><strong>Solution</strong> The following statements are equivalent &gt; <span class="math inline">R</span> is reflexive<br />
&gt; <span class="math inline">a &lt;= a</span> for all <span class="math inline">a\in A</span><br />
&gt; <span class="math inline">(a, a)\in R</span> for all <span class="math inline">a\in A</span><br />
&gt; <span class="math inline">1_A</span> is a subset of <span class="math inline">R</span></p>
<p><strong>Excercise</strong>. 6. Show <span class="math inline">R</span> is transitive if and only if <span class="math inline">RR</span> is a subset of <span class="math inline">R</span>_.</p>
<p><strong>Solution</strong> The following statements are equivalent &gt; <span class="math inline">R</span> is transitive<br />
&gt; <span class="math inline">a &lt;= b</span> and <span class="math inline">b &lt;= c</span> imply <span class="math inline">a &lt;= c</span><br />
&gt; <span class="math inline">(a, b)\in R</span> and <span class="math inline">(b, c)\in R</span> imply <span class="math inline">(a, c)\in R</span><br />
&gt; <span class="math inline">(a, c)\in RR</span> implies <span class="math inline">(a, c)\in R</span><br />
&gt; <span class="math inline">RR</span> is a subset of <span class="math inline">R</span></p>
<p><strong>Excercise</strong>. 7. Show <span class="math inline">R</span> is anti-symmetric if and only if the intersection of <span class="math inline">R</span> and <span class="math inline">R*</span> is contained in <span class="math inline">1_A</span>_.</p>
<p><strong>Solution</strong> The following statements are equivalent &gt; <span class="math inline">R</span> is anti-symmetric<br />
&gt; <span class="math inline">a &lt;= b</span> and <span class="math inline">b &lt;= a</span> imply <span class="math inline">a = b</span><br />
&gt; <span class="math inline">(a, b)\in R</span> and <span class="math inline">(b, a)\in R</span> imply <span class="math inline">a = b</span><br />
&gt; <span class="math inline">(a, b)\in R</span> and <span class="math inline">(a, b)\in R*</span> imply <span class="math inline">a = b</span><br />
&gt; <span class="math inline">(a, b)\in R intersect R*</span> imply <span class="math inline">(a, b)\in 1_A</span><br />
&gt; The intersection of <span class="math inline">R</span> and <span class="math inline">R*</span> is contained in <span class="math inline">1_A</span></p>
<footer>
Return to <a href="index.html">index</a>.
</footer>
</body>
</html>
