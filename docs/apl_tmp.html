<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Keith A. Lewis" />
  <title>APL</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="math.css" />
  <script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" />
</head>
<body>
<header>
<h1 class="title">APL</h1>
<p class="author">Keith A. Lewis</p>
</header>

<p>\newcommand\from{</p>
<blockquote>
<p>APL is a mistake carried through to perfection — Edsgar W. Dijkstra</p>
</blockquote>
<p>A Programming Language <em>APL</em> was invented by Ken E. Iverson, a mathematician unsatisfied by the limited expressiveness of FORTRAN when it came to manipulating multidimensional arrays. What follows is a mathematical description of the objects and operations on them he envisioned to scratch that itch. It is simply a matter of giving explicit names to the operations that can be performed on collections of data; what Iverson called “tools of thought.”</p>
<p>There have been many languages inspired by APL and this writeup takes liberties with the classical language. Our approach is informed by advances in mathematics and best practices for implmementing functional languages on current computer architectures. We take a purely functional view so no side effects are allowed and data cannot be mutated. Similar to Everett’s many-world interpretation, this makes it easy to reason about programs mathematically, but can be hard on computers computationally. Using lazy evaluation, lenses, and other implementation techniques can help with that.</p>
<h2 id="set">Set</h2>
<p>Given a function <span class="math inline">\(f\colon X\to Y\)</span> we write <span class="math inline">\(f(x)\)</span> as <span class="math inline">\(fx\)</span>. If <span class="math inline">\(g\colon Y\to Z\)</span> we write the composition <span class="math inline">\(g(f(x))\)</span> as <span class="math inline">\(gfx\)</span>. Right to left association is natural in functional languages to chain application. If <span class="math inline">\(h\colon Z\to W\)</span> then <span class="math inline">\(h(gf) = (hg)f\)</span> so writing <span class="math inline">\(hgf\)</span> is unambiguous. The identity function of a set <span class="math inline">\(X\)</span> is <span class="math inline">\(1_X\colon X\to X\)</span> with <span class="math inline">\(1_X(x) = x\)</span>, <span class="math inline">\(x\in X\)</span> and <span class="math inline">\(f1_X = f = 1_Yf\)</span> whenever <span class="math inline">\(f\colon X\to Y\)</span>. Sets and functions are the objects and arrows of a category called <span class="math inline">\(\mathbf{Set}\)</span>.</p>
<p>This category is <em>cartesian closed</em>; it has products and exponetials. The product of sets <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> is the cartesian product <span class="math inline">\(X\times Y = \{(x,y):x\in X, y\in Y\}\)</span> is the set of all pairs from each set and the exponential <span class="math inline">\(Y^X = \{f\colon X\to Y\}\)</span> is the set of functions from <span class="math inline">\(X\)</span> to <span class="math inline">\(Y\)</span>.</p>
<p>They are related by <span class="math inline">\(Z^{X\times Y}\)</span> is in one-to-one correspondence with <span class="math inline">\(Z^{Y^X}\)</span>. Every <span class="math inline">\(f\in Z^{X\times Y}\)</span> corresponds to <span class="math inline">\(g\in Z^{Y^X}\)</span> via <span class="math inline">\(f(x,y) = z\)</span> if and only if <span class="math inline">\(g(x)(y) = (gx)y = z\)</span>, <span class="math inline">\(x\in X\)</span>, <span class="math inline">\(y\in Y\)</span>, <span class="math inline">\(z\in Z\)</span>. This can be written <span class="math inline">\((X\times Y)\to Z \leftrightarrow X\to(Y\to Z)\)</span>.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> Going from left to right is <em>currying</em> and going from right to left is <em>uncurrying</em>. Given <span class="math inline">\(f\colon X\times Y\to Z\)</span> we write <span class="math inline">\(fx\colon Y\to Z\)</span> for <em>partial application</em> instead of <span class="math inline">\(g(x)\)</span>.</p>
<p>The cartesian product of a set <span class="math inline">\(X\)</span> with itself <span class="math inline">\(n\)</span> times, <span class="math inline">\(X^n\)</span>, can be identified with the set of functions <span class="math inline">\(n\to X\)</span> if we use the convention <span class="math inline">\(n = \{0,\ldots,n-1\}\)</span>. The element <span class="math inline">\(x = (x_0,\ldots,n-1)\)</span> of the cartesian product corresponds to the function <span class="math inline">\(x\colon n\to X\)</span> via <span class="math inline">\(x_i = x(i)\)</span>, <span class="math inline">\(i\in n\)</span>.</p>
<h3 id="product">Product</h3>
<p>The cartesian product of a set <span class="math inline">\(X\)</span> with itself <span class="math inline">\(Y\)</span> times, <span class="math inline">\(\Pi X_Y = \Pi_{y\in Y} X\)</span>, can be defined for any set <span class="math inline">\(Y\)</span>. As above, it can be identified with <span class="math inline">\(X^Y\)</span>. The product has <em>projections</em> <span class="math inline">\(\pi_y\colon \Pi X_y\to X\)</span> defined by <span class="math inline">\(\pi_y a = a(y)\)</span>, $yY. We write <span class="math inline">\(\pi_y a = a_y\)</span> and <span class="math inline">\(a = (a_y)\)</span> <em>as an array</em> in the product for <span class="math inline">\(a\)</span> <em>as a function</em> in the exponential.</p>
<p><strong>Exercise</strong>. <em>If <span class="math inline">\(a,b\in\Pi X_Y\)</span> and <span class="math inline">\(\pi_y a = \pi_y b\)</span> for all <span class="math inline">\(y\in Y\)</span> then <span class="math inline">\(a = b\)</span> as functions in <span class="math inline">\(Y^X\)</span></em>.</p>
<p>Note <span class="math inline">\(\Pi X_Y\)</span> is not equal to <span class="math inline">\(X^Y\)</span>, but they are <em>isomorphic</em>. Define <span class="math inline">\(\eta\colon X^Y\to \Pi X_Y\)</span> by <span class="math inline">\(\pi_y(\eta a) = a(y)\)</span> and <span class="math inline">\(\epsilon\colon\Pi X_Y\to X^Y\)</span> by <span class="math inline">\((\epsilon a)y = \pi_y a\)</span>.</p>
<p><strong>Exercise</strong>. <em>Show <span class="math inline">\(\epsilon\eta\)</span> is the identity on <span class="math inline">\(\Pi X_Y\)</span> and <span class="math inline">\(\eta\epsilon\)</span> is the identity on <span class="math inline">\(\Pi X_Y\)</span></em>.</p>
<h3 id="each">Each</h3>
<p>If <span class="math inline">\(f\colon X\to Y\)</span> and <span class="math inline">\(x\colon Z\to X\)</span> then <span class="math inline">\(fx\colon Z\to Y\)</span>. This can be viewed as a function <span class="math inline">\(f^Z\colon X^Z\to Y^Z\)</span>. It is common to call this <em>apply</em> or <em>map</em>, but in APL it is called <em>each</em>. With <span class="math inline">\(X^Z\)</span> and <span class="math inline">\(Y^Z\)</span> as products, <span class="math inline">\(x\mapsto fx\)</span> where <span class="math inline">\((fx)_z = f(x_z)\)</span></p>
<h3 id="index">Index</h3>
<p>If <span class="math inline">\(y\colon Y\to Z\)</span> and <span class="math inline">\(f\colon X\to Y\)</span> then <span class="math inline">\(yf\colon X\to Z\)</span>. This can be viewed as a function <span class="math inline">\(f_Z\colon Z^Y\to Z^X\)</span>. It is common to call this <em>projection</em>, but in APL it is called <em>index</em>. With <span class="math inline">\(Z^Y\)</span> and <span class="math inline">\(Z^X\)</span> as products, <span class="math inline">\(y\mapsto yf\)</span> where <span class="math inline">\((yf)_x = y_{fx}\)</span>. Given <span class="math inline">\(Z^X\)</span> as a product, <span class="math inline">\(Z^Y\)</span> is a product on the indices selected by <span class="math inline">\(f\)</span>. If <span class="math inline">\(I\subseteq Y\)</span> and <span class="math inline">\(f\colon I\to Y\)</span> is the inclusion map then <span class="math inline">\(Z^Y\to Z^I\)</span> is the projection <span class="math inline">\(\Pi Z_Y\to \Pi Z_I\)</span>. The inclusion map is written <span class="math inline">\([I]\)</span> if <span class="math inline">\(Y\)</span> is understood.</p>
<p>APL is primarily concerned with arrays <span class="math inline">\(X^{n_0\times\cdots n_{m-1}}\)</span> and giving names to the functions operating on those. Most often <span class="math inline">\(X\)</span> is <span class="math inline">\(\bm{R}\)</span>, the set of real numbers, but <span class="math inline">\(X\)</span> can also be a set of characters.</p>
<h2 id="example">Example</h2>
<p>APL lets you turn a number into a lot of numbers. The function <span class="math inline">\(\iota\)</span> (iota) is used to produce sequences. If <span class="math inline">\(n\in \bm{N}\)</span> then <span class="math inline">\(\iota n = (0, 1, \ldots n-1)\)</span> where <span class="math inline">\(\bm{N}\)</span> is the set of natural numbers. It gives a name related to our convention <span class="math inline">\(n = \{0,\ldots, n-1\}\)</span> but there is a difference: <span class="math inline">\(\iota n\)</span> is not a set, it is an element of <span class="math inline">\(\bm{N}^n\)</span>. Note <span class="math inline">\((\iota n)_i = i\)</span>, <span class="math inline">\(i\in n\)</span> so <span class="math inline">\(\iota n\)</span> is the identity function on <span class="math inline">\(n\)</span>.</p>
<p>In two dimensions the <span class="math inline">\(n\times n\)</span> identity matrix is <span class="math inline">\((\delta_{ij})_{i,j\in n}\in \bm{N}^{n\times n}\)</span>. In APL it is <span class="math inline">\(\delta\)</span> applied to each element of <span class="math inline">\(n\times n\)</span>. The elements of <span class="math inline">\(n\times n\)</span> are <span class="math inline">\(\{(i,j):i,j\in n\}\)</span> so <span class="math inline">\(\delta n\times n = \{\delta(i,j):(i,j)\in n\times n\}\)</span>.</p>
<p>We can define <span class="math inline">\(\delta\colon X^n\to X\)</span> for any <span class="math inline">\(n\)</span> by <span class="math inline">\(\delta(x_0,\ldots,x_n-1) = 1\)</span> if all <span class="math inline">\(x_i\)</span> are equal and <span class="math inline">\(0\)</span> otherwise. In APL we use <span class="math inline">\(\text{$=$}\)</span> instead of pussyfooting around with <span class="math inline">\(\delta\)</span>. We should probably use <code>true</code> and <code>false</code> instead of <span class="math inline">\(1\)</span> and <span class="math inline">\(0\)</span>. If <span class="math inline">\(X\)</span> is the name of the <em>type converion</em> function <code>true</code><span class="math inline">\(\mapsto 1\)</span> and <code>false</code><span class="math inline">\(\mapsto 0\)</span> we would write <span class="math inline">\(X(\delta)\)</span>, or <span class="math inline">\(X\delta\)</span>, instead of <span class="math inline">\(\delta\)</span>.</p>
<p>But wait, that’s not all! This can be written more succinctly as <span class="math inline">\(\text{$=$}n^2\)</span> since <span class="math inline">\(n^2\)</span> is equivalent to <span class="math inline">\(n\times n\)</span>. The <span class="math inline">\(k\)</span>-dimensional identity matrix is <span class="math inline">\(\text{$=$}n^k\)</span>. If we define <span class="math inline">\(\from(A, B) = A\from B = A^B\)</span>, ⍣ in APL, then <span class="math inline">\(\text{$=$}\from\)</span> allows us to parameterize over <span class="math inline">\(n\)</span> too since <span class="math inline">\(\text{$=$}\from(n,k)\)</span> is <span class="math inline">\(\text{$=$}n^k\)</span>.</p>
<p>Never play code golf with an APLer.</p>
<h3 id="reduce">Reduce</h3>
<p>APL also lets you turn a lot of numbers into one number. For instance, <span class="math inline">\(+/(a_0,\ldots,a_n) = a_0 + \cdots + a_n\)</span> where slash (<span class="math inline">\(/\)</span>) is called <em>reduce</em>. Other languages call this <em>fold</em>.</p>
<p>Any binary operator <span class="math inline">\(\bullet\colon X\times X\to X\)</span> can be extended to <span class="math inline">\(\bullet/\colon X^n\colon X\)</span> for <span class="math inline">\(n &gt; 2\)</span> inductively by <span class="math inline">\(\bullet/(x_0, x_1, \ldots) = x_0 \bullet (\bullet/(x_1, \dots))\)</span>. This is called <em>right reduce</em>. If the array is finite then then <em>left reduce</em> is <span class="math inline">\(/\bullet(x_0,\ldots,x_n) = (/\bullet(x_0,\ldots,x_{n-1}))\bullet x_n\)</span>. Here we are using <em>infix notation</em> <span class="math inline">\(\bullet(x,y) = x\bullet y\)</span>.</p>
<p>If <span class="math inline">\(\bullet\)</span> is associative then right and left right reduce are equal. If we define <span class="math inline">\(\bullet/(x) = x\)</span> then <span class="math inline">\(\bullet/(x,y) = (\bullet/x)\bullet(\bullet/y)\)</span> where <span class="math inline">\((x,y)\)</span> is the concatenation of array <span class="math inline">\(x\)</span> with array <span class="math inline">\(y\)</span>. Likewise for <span class="math inline">\(/\bullet\)</span>. If <span class="math inline">\(\bullet\)</span> has an <em>identity element</em> <span class="math inline">\(e\in X\)</span> we can define <span class="math inline">\(\bullet/\emptyset = e = /\bullet\emptyset\)</span> and this holds when <span class="math inline">\(x\)</span> or <span class="math inline">\(y\)</span> are empty. These conditions make <span class="math inline">\(X\)</span> a <em>monoid</em> under <span class="math inline">\(\bullet\)</span>.</p>
<p>If the binary operation is commutative then changing the order of the array elements does not alter the result.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>In fancy pants category theory language this is expressed as the product functor <span class="math inline">\(F_Y(X) = X\times Y\)</span> and the exponential functor <span class="math inline">\(G_Y(Z) = Z^Y\)</span> are adjoint: <span class="math inline">\(\operatorname{hom}(F_Y(X),Z)\cong\operatorname{hom}(X,G_Y(Z))\)</span>.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
<footer>
Return to <a href="index.html">index</a>.
</footer>
</body>
</html>
